{
  "version": 3,
  "file": "index.css",
  "sources": [
    "../AppUI.svelte",
    "../FeaturePropTopValues.svelte",
    "../FeaturePopup.svelte",
    "../PropertySearchField.svelte"
  ],
  "sourcesContent": [
    "<svelte:window on:keydown=\"handleKeyPress(event)\" />\r\n\r\n<!-- Render full UI -->\r\n<div id=\"controls_left\" class=\"column\">\r\n  <div id=\"spaces\" class=\"panel\">\r\n    <div id=\"space_info\">\r\n      {#if spaceInfo}\r\n        <div>\r\n          <!-- Demo/inspect mode toggle-->\r\n          <button on:click=\"set({ demoMode: !demoMode })\" class=\"demoModeToggle\">\r\n            {demoMode ? 'inspect' : 'demo'}\r\n          </button>\r\n\r\n          <!-- Space info -->\r\n          <div>{spaceInfo.title}</div>\r\n          {#if !demoMode}\r\n            <div>{spaceId}: {spaceInfo.numFeatures.toLocaleString()} features, {spaceInfo.dataSize}, {spaceInfo.featureSize}</div>\r\n            {#if spaceInfo.updatedAt}\r\n              <div>{spaceInfo.updatedAt}</div>\r\n            {/if}\r\n            <div style=\"font-size:10px;\">{spaceInfo.description}</div>\r\n          {/if}\r\n        </div>\r\n      {:elseif !spaceLoading}\r\n        <input type=\"text\" placeholder=\"enter an XYZ space ID\" bind:value='spaceId'>\r\n        <button on:click=\"updateSpace(true)\">Show XYZ Space</button>\r\n      {/if}\r\n    </div>\r\n    <div id=\"style_info\" class:hideInDemoMode=\"demoMode\">\r\n      {#if displayToggles}\r\n        <table>\r\n          <tr>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"roads\")'>roads:</td>\r\n            <td>{displayToggles.roads}</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"buildings\")'>buildings:</td>\r\n            <td>{displayToggles.buildings}</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"water\")'>water:</td>\r\n            <td>{displayToggles.water}</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"places\")'>places:</td>\r\n            <td>{displayToggles.places}</td>\r\n          </tr>\r\n          <tr>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"points\")'>points:</td>\r\n            <td>{displayToggles.points}</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"lines\")'>lines:</td>\r\n            <td>{displayToggles.lines}</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"outlines\")'>outlines:</td>\r\n            <td>{displayToggles.outlines}</td>\r\n          </tr>\r\n        </table>\r\n        <table>\r\n          <tr>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"clustering\")'>clustering:</td>\r\n            {#if displayToggles.clustering == 0}\r\n            <td>\r\n<!--             {#if tokenCapabilities.hexbinClustering || tokenCapabilities.quadClustering} -->\r\n             off\r\n<!--             {:else} -->\r\n<!--              sign up for XYZ Pro to cluster -->\r\n<!--             {/if} -->\r\n            </td>\r\n            {/if}\r\n            {#if displayToggles.clustering == 1}\r\n            <td>H3 hexbins</td>\r\n            {/if}\r\n            {#if displayToggles.clustering == 2}\r\n            <td>H3 hexbin centroids</td>\r\n            {/if}\r\n            {#if displayToggles.clustering == 3}\r\n            <td>Quadbins</td>\r\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"quadRez\")'>resolution:</td>\r\n            <td>{displayToggles.quadRez}</td>\r\n            {/if}\r\n          </tr>\r\n        </table>\r\n        \r\n        {#if gisInfo.voronoi || gisInfo.delaunay}\r\n        <table>\r\n          <tr>\r\n            <td>GIS:</td>\r\n            {#if gisInfo.voronoi}\r\n              <td style=\"color:blue;\" on:click='toggleDisplayOption(\"voronoi\")'>Voronoi:</td>\r\n              <td>\r\n              {#if displayToggles.voronoi == 0}\r\n              off\r\n              {/if}\r\n              {#if displayToggles.voronoi == 1}\r\n              {gisInfo.voronoi}\r\n              {/if}\r\n              </td>\r\n            {/if}\r\n            {#if gisInfo.delaunay}\r\n              <td style=\"color:blue;\" on:click='toggleDisplayOption(\"delaunay\")'>Delaunay:</td>\r\n              <td>\r\n              {#if displayToggles.delaunay == 0}\r\n              off\r\n              {/if}\r\n              {#if displayToggles.delaunay == 1}\r\n              {gisInfo.delaunay}\r\n              {/if}\r\n              </td>\r\n            {/if}\r\n          </tr>\r\n        </table>\r\n        {/if}\r\n      \r\n        {#if hexbinInfo.spaceId}\r\n          <table>\r\n              <tr>\r\n                <td style=\"color:blue;\" on:click='toggleDisplayOption(\"hexbins\")'>\r\n                  CLI hexbins: </td><td>\r\n                  {#if displayToggles.hexbins == 0}\r\n                  off\r\n                  {/if}\r\n                  {#if displayToggles.hexbins == 1}\r\n                  on\r\n                  {/if}\r\n                  {#if displayToggles.hexbins == 2}\r\n                  centroids\r\n                  {/if}\r\n                </td>\r\n              </tr><tr>\r\n                <td>{hexbinInfo.spaceId}, zoom {hexbinInfo.zoomLevels}</td>\r\n              </tr>\r\n          </table>\r\n        {/if}\r\n\r\n        <!-- Basemap selector -->\r\n        <div class=\"controls_left_selector\">basemap:\r\n          <select bind:value=\"basemap\" class=\"controls_left_dropdown\">\r\n            {#each Object.keys(basemaps) as basemap}\r\n              <option value=\"{basemap}\">{basemap}</option>\r\n            {/each}\r\n          </select>\r\n        </div>\r\n\r\n        {#if isProjectable(basemap) }\r\n          <!-- Projection selector -->\r\n          <div class=\"controls_left_selector\">projection:\r\n            <select bind:value=\"projection\" class=\"controls_left_dropdown\">\r\n              {#each Object.keys(projections) as projection}\r\n                <option value=\"{projection}\">{projection}</option>\r\n              {/each}\r\n            </select>\r\n          </div>\r\n        {/if}\r\n\r\n        <!-- Export scene -->\r\n          <button on:click=\"fire('exportScene')\" style=\"float: right;\">export</button>\r\n      {/if}\r\n    </div>\r\n\r\n    <!-- Demo mode context -->\r\n    {#if demoMode && displayToggles.label != null}\r\n      <!-- Selected label property and value info -->\r\n      <div style=\"margin: 5px 0px;\">\r\n        Features labeled by <b>{displayToggles.label}</b>\r\n      </div>\r\n    {/if}\r\n\r\n    {#if demoMode && featurePointSizeProp != null}\r\n      <!-- Selected point size property and value info -->\r\n      <div style=\"margin: 5px 0px;\">\r\n        Points scaled by <b>{featurePointSizeProp}</b>\r\n      </div>\r\n    {/if}\r\n\r\n    {#if demoMode && featureProp && featurePropCount != null}\r\n      <!-- Selected feature property and value info -->\r\n      <div style=\"margin: 5px 0px;\">\r\n        Analyzing property <b>{featureProp}</b> by <b>{displayToggles.vizMode}</b>\r\n      </div>\r\n\r\n      <!-- Histogram for demo mode -->\r\n      {#if displayToggles.vizMode === 'range'}\r\n        <div class=\"hideOnMobilePortrait\">\r\n          <FeaturePropHistogram\r\n            showHeader={false}\r\n            minFilter={featurePropMinFilter}\r\n            maxFilter={featurePropMaxFilter}\r\n            valueCounts={sortedFeaturePropValueCounts}\r\n            valueColorFunction={featurePropValueColorFunction}\r\n          />\r\n        </div>\r\n      {:elseif displayToggles.vizMode === 'rank' && featurePropValueCounts}\r\n        <!-- Top values list -->\r\n        <div class=\"hideOnMobilePortrait\">\r\n          <FeaturePropTopValues\r\n            showHeader={false}\r\n            prop={featureProp}\r\n            bind:propValue=\"featurePropValue\"\r\n            bind:valueSort=\"featurePropValueSort\"\r\n            valueCounts={sortedFeaturePropValueCounts}\r\n            valueColorFunction={featurePropValueColorFunction}\r\n          />\r\n        </div>\r\n      {:elseif displayToggles.vizMode === 'property'}\r\n        <!-- Top values list -->\r\n        <div class=\"hideOnMobilePortrait\">\r\n          <FeaturePropTopValues\r\n            showHeader={false}\r\n            prop={featureProp}\r\n            bind:propValue=\"featurePropValue\"\r\n            bind:valueSort=\"featurePropValueSort\"\r\n            valueCounts={sortedFeaturePropValueCounts}\r\n            valueColorFunction={featurePropValueColorFunction}\r\n          />\r\n        </div>\r\n      {/if}\r\n    {/if}\r\n  </div>\r\n\r\n  <div id=\"viz\" class=\"panel hideOnMobilePortrait\" class:hideInDemoMode=\"demoMode\">\r\n    <div>\r\n      <!-- Selected feature property stats -->\r\n      {#if featureProp && featurePropCount != null}\r\n        <div style=\"margin: 5px 0 5px 0;\" class=\"hideOnMobile\">\r\n          <div>{featurePropCount} unique values in the viewport</div>\r\n\r\n          {#if featurePropMin != null}\r\n            <div>min: {featurePropMin}, median: {featurePropMedian}, max: {featurePropMax}</div>\r\n            <div>\r\n              μ: {featurePropMean.toFixed(2)},\r\n              σ: {featurePropStdDev.toFixed(2)},\r\n              {featurePropSigma.toFixed(2)}% ({featurePropSigmaFloor.toFixed(2)} - {featurePropSigmaCeiling.toFixed(2)})\r\n            </div>\r\n          {/if}\r\n        </div>\r\n      {/if}\r\n\r\n      <!-- Color mode selector -->\r\n      {#if displayToggles}\r\n        <div>\r\n          Analyze by\r\n          <select bind:value=\"displayToggles.vizMode\" on:change=\"updateFeaturePropValueSort()\">\r\n            {#each Object.keys(vizModes) as mode}\r\n              {#if featureProp || !vizModeUsesProperty(mode)}\r\n                <option value=\"{mode}\">{vizModes[mode].label || mode}</option>\r\n              {/if}\r\n            {/each}\r\n          </select>\r\n        </div>\r\n      {/if}\r\n\r\n      {#if sortedUniqueFeaturePropsSeen.length > 0 && vizModeUsesProperty(displayToggles.vizMode)}\r\n        <!-- Visualize property selector -->\r\n        <div class=\"property_selector\">\r\n          <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Visualize by property</span>\r\n          <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featureProp\">\r\n            <option value=\"\"></option>\r\n            <!-- JSON.stringify is a hint to help Svelte uniquely identify the object values -->\r\n            <!-- see https://v2.svelte.dev/guide#keyed-each-blocks -->\r\n            {#each sortedUniqueFeaturePropsSeen as [prop] (JSON.stringify(prop))}\r\n              <option value=\"{prop}\">{prop}</option>\r\n            {/each}\r\n          </select>\r\n        </div>\r\n\r\n        <!-- Filter value selector -->\r\n        {#if featureProp && featurePropValueCounts}\r\n          <div class=\"property_selector\">\r\n            <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Filter by value</span>\r\n            <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featurePropValue\">\r\n              <option value=\"\"></option>\r\n              {#each featurePropValueCounts as [value, count]}\r\n                <option value=\"{value}\">({count}x) {value}</option>\r\n              {/each}\r\n            </select>\r\n          </div>\r\n        {/if}\r\n      {/if}\r\n\r\n\r\n      {#if featureProp && featurePropCount != null}\r\n        <!-- Pattern selector -->\r\n        {#if displayToggles}\r\n          <div class=\"property_selector\">\r\n            <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Pattern</span>\r\n            <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.pattern\">\r\n              {#each patternOptions as pattern}\r\n                <option value=\"{pattern}\">{pattern}</option>\r\n              {/each}\r\n            </select>\r\n          </div>\r\n\r\n          {#if displayToggles.pattern}\r\n            <div class=\"property_selector\">\r\n              <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Pattern color</span>\r\n              <input style=\"flex: 1 1 auto; width: 100%;\" type=\"color\" bind:value=\"displayToggles.patternColor\">\r\n            </div>\r\n          {/if}\r\n        {/if}\r\n\r\n        <!-- Color palette and range filters -->\r\n        {#if showFeaturePropPalette(displayToggles.vizMode)}\r\n          <div class=\"hideOnMobile\">\r\n            Color palette\r\n            <select bind:value=\"featurePropPaletteName\">\r\n              {#each Object.keys(colorPalettes) as palette}\r\n                <option value=\"{palette}\">{palette}</option>\r\n              {/each}\r\n            </select>\r\n\r\n            <label>\r\n              <input type=\"checkbox\" bind:checked=\"featurePropPaletteFlip\">\r\n              Flip\r\n            </label>\r\n          </div>\r\n\r\n          {#if featurePropMin != null}\r\n            {#if useFeaturePropRangeLimit(displayToggles.vizMode)}\r\n              <div>\r\n                Limit values:\r\n                <select bind:value=\"featurePropRangeFilter\" on:change=\"updateFeaturePropRangeFilter(this.value)\">\r\n                  <option value=\"0\">all</option>\r\n                  <option value=\"4\">sigma 4</option>\r\n                  <option value=\"3\">sigma 3</option>\r\n                  <option value=\"2\">sigma 2</option>\r\n                  <option value=\"1\">sigma 1</option>\r\n                  <option value=\"custom\" class=\"hideOnMobile\">custom</option>\r\n                </select>\r\n                <input class=\"range_filter hideOnMobile\" type=\"text\" bind:value=\"featurePropMinFilterInput\" placeholder=\"min\" on:input=\"updateFeaturePropRangeFilter('custom')\" on:keydown=\"event.stopPropagation()\">\r\n                <input class=\"range_filter hideOnMobile\" type=\"text\" bind:value=\"featurePropMaxFilterInput\" placeholder=\"max\" on:input=\"updateFeaturePropRangeFilter('custom')\" on:keydown=\"event.stopPropagation()\">\r\n              </div>\r\n\r\n              <label style=\"margin-bottom: 5px;\">\r\n                <input type=\"checkbox\" bind:checked=\"featurePropHideOutliers\">\r\n                Hide values outside range\r\n              </label>\r\n\r\n              {#if featurePropMostlyNumeric}\r\n                <FeaturePropHistogram\r\n                  minFilter={featurePropMinFilter}\r\n                  maxFilter={featurePropMaxFilter}\r\n                  valueCounts={sortedFeaturePropValueCounts}\r\n                  valueColorFunction={featurePropValueColorFunction}\r\n                />\r\n              {/if}\r\n            {/if}\r\n          {/if}\r\n        {/if}\r\n      {/if}\r\n    </div>\r\n\r\n    {#if sortedUniqueFeaturePropsSeen.length > 0}\r\n      <!-- Label property selector -->\r\n      <div class=\"property_selector\">\r\n        <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Label features by</span>\r\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.label\">\r\n          <option value=\"\"></option>\r\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\r\n            <option value=\"{prop}\">{prop}</option>\r\n          {/each}\r\n        </select>\r\n      </div>\r\n\r\n      <!-- Point size property selector -->\r\n      <div class=\"property_selector\">\r\n        <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Scale point size by</span>\r\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featurePointSizeProp\">\r\n          <option value=\"\"></option>\r\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\r\n            <!-- {#if isPropNumeric(parsePropStack(prop), { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold })} -->\r\n              <option value=\"{prop}\">{prop}</option>\r\n            <!-- {/if} -->\r\n          {/each}\r\n        </select>\r\n      </div>\r\n\r\n      <!-- Point min/max pixel size -->\r\n      {#if featurePointSizeProp}\r\n        <div class=\"property_selector hideOnMobile\">\r\n          <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Point size (px):</span>\r\n          <input style=\"flex: 1 1 auto; width: 100%;\" class=\"range_filter\" type=\"text\" bind:value=\"featurePointSizeDisplayRange[0]\" placeholder=\"min\" on:keydown=\"event.stopPropagation()\">\r\n          <input style=\"flex: 1 1 auto; width: 100%;\" class=\"range_filter\" type=\"text\" bind:value=\"featurePointSizeDisplayRange[1]\" placeholder=\"max\" on:keydown=\"event.stopPropagation()\">\r\n        </div>\r\n      {/if}\r\n    {/if}\r\n\r\n    {#if !(featureProp && featurePropCount != null)}\r\n      Select a feature property to analyze, from the property list or by clicking on an individual feature.\r\n    {/if}\r\n    \r\n    <!-- clustering property selector -->\r\n    {#if sortedUniqueFeaturePropsSeen.length > 0 && displayToggles.clustering > 0}\r\n      <div style=\"display: flex; flex-direction: row; align-items: center; margin: 5px 0px;\">\r\n        <span style=\"flex: 0 0 auto; margin-right: 5px;\">Cluster features by</span>\r\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.clusteringProp\">\r\n          <option value=\"\"></option>\r\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\r\n            <option value=\"{prop}\">{prop}</option>\r\n          {/each}\r\n        </select>\r\n      </div>\r\n    {/if}\r\n\r\n    <!-- Top values list -->\r\n    {#if featureProp && featurePropValueCounts}\r\n      <div class=\"hideOnMobile\">\r\n        <FeaturePropTopValues\r\n          prop={featureProp}\r\n          bind:propValue=\"featurePropValue\"\r\n          bind:valueSort=\"featurePropValueSort\"\r\n          valueCounts={sortedFeaturePropValueCounts}\r\n          valueColorFunction={featurePropValueColorFunction}\r\n        />\r\n      </div>\r\n    {/if}\r\n  </div>\r\n</div>\r\n\r\n<div id=\"controls_right\" class=\"column hideOnMobile\" class:hideInDemoMode=\"demoMode\">\r\n  <div id=\"tag_summary\" class=\"panel\">\r\n    <table id=\"tag_stats\">\r\n      {#if featuresInViewport.length}\r\n        <tr><td>features in viewport</td><td>{featuresInViewport.length}</td></tr>\r\n      {/if}\r\n      {#if numFeatureTagsInViewport != null}\r\n        <tr><td>feature tags in viewport</td><td>{numFeatureTagsInViewport}</td></tr>\r\n      {/if}\r\n      <tr><td>unique tags in viewport</td><td>{uniqueTagsInViewport.size}</td></tr>\r\n      <tr><td>unique tags seen</td><td>{uniqueTagsSeen.size}</td></tr>\r\n    </table>\r\n    <div id=\"tags_filtered\">\r\n      filtering by tags:<br>\r\n      {#if tagFilterList.length > 0}\r\n        {tagFilterList.join(', ')}<br><br>\r\n      {:else}\r\n        <i>no tags filtered<br><br></i>\r\n      {/if}\r\n    </div>\r\n    <div style=\"color:blue;\" id=\"clear_filters\" on:click=\"set({ tagFilterList: [] })\">CLEAR TAG FILTERS</div>\r\n    <div id=\"and_or\">\r\n      <input type=\"radio\" g=\"and_or\" value=\"or\" bind:group='tagFilterAndOr'>or\r\n      <input type=\"radio\" name=\"and_or\" value=\"and\" bind:group='tagFilterAndOr'>and<br>\r\n    </div>\r\n  </div>\r\n  <div id=\"tag_panel\" class=\"panel\">\r\n    <span style=\"color:blue;\" on:click=\"toggleTagFilterViewport()\">\r\n      {#if tagFilterViewport}\r\n        [show all tags seen]\r\n      {:else}\r\n        [only show tags in view]\r\n      {/if}\r\n    </span>\r\n    <span style=\"color:blue;\" on:click=\"toggleTagFilterAt()\">\r\n      {#if tagFilterAt}\r\n        [show all tag names]\r\n      {:else}\r\n        [only show @ tags]\r\n      {/if}\r\n    </span>\r\n    <span style=\"color:blue;\" on:click=\"toggleTagSort()\">\r\n      [sort by {nextTagSort}]\r\n    </span>\r\n    <div id=\"tags\">\r\n      <div>\r\n        <input id=\"tag_search\" type=\"text\" bind:value=\"tagFilterSearch\" placeholder=\"Filter tags\" on:keydown=\"event.stopPropagation()\">\r\n      </div>\r\n\r\n      <!-- The JSON.stringify gives Svelte a way to uniquely identify the full tag info.\r\n        This ensures that the correct checkboxes stay checked when the list is re-ordered\r\n        (for instance when tag counts change). See https://svelte.technology/guide#keyed-each-blocks.\r\n      -->\r\n      {#each tagDisplayList.slice(0, 500) as tag (JSON.stringify(tag))}\r\n        <label>\r\n          <input type=\"checkbox\" value=\"{tag[0]}\" bind:group='tagFilterList'>\r\n          ({tag[1]}x) {tag[0]}\r\n        </label>\r\n        <br>\r\n      {/each}\r\n\r\n      {#if tagDisplayList.length > 500}\r\n        <i>Displaying the top 500 tags of {tagDisplayList.length} total</i>\r\n      {/if}\r\n    </div>\r\n  </div>\r\n\r\n  <!-- property search UI-->\r\n  {#if spaceInfo && spaceInfo.properties}\r\n    <div id=\"properties\" class=\"panel hideOnMobile\">\r\n      <PropertySearchList\r\n        properties={spaceInfo.properties}\r\n        bind:propertySearch=\"propertySearch\"\r\n      />\r\n    </div>\r\n  {/if}\r\n</div>\r\n\r\n<!-- feature popup content, hidden in the main UI and synced to the Leaflet popup -->\r\n<div style=\"display: none\">\r\n  <div id=\"popupContent\" style=\"margin-top: 18px;\">\r\n    <FeaturePopup\r\n      feature={feature}\r\n      featureProp={featureProp}\r\n      featurePinned={featurePinned}\r\n      featurePropValue={featurePropValue}\r\n      on:selectProp=\"setFeatureProp({\r\n        featureProp: (event.prop !== featureProp ? event.prop : null),\r\n        featurePropValue: ''\r\n      })\"\r\n      on:selectValue=\"setFeatureProp({\r\n        featureProp: event.prop,\r\n        featurePropValue: (event.value !== featurePropValue ? event.value : '')\r\n      })\"\r\n    />\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n\r\nimport { basemaps, getBasemapScene, getBasemapName, getDefaultBasemapName, getNextBasemap,\r\n          projections, getProjectionScene, getDefaultProjectionName, isProjectable, } from './basemaps';\r\nimport { colorPalettes } from './colorPalettes';\r\nimport { vizModes, vizHelpers } from './vizModes';\r\nimport { displayOptions, defaultDisplayOptionValue } from './displayOptions';\r\nimport { calcFeaturePropertyStats } from './stats';\r\nimport { parseNestedObject, parsePropStack, formatPropStack, parseNumber, mostlyNumeric, lookupProperty, PROP_TYPES } from './utils';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      // set these to empty strings (not null) to get placeholder text in input\r\n      spaceId: '',\r\n      token: '',\r\n      spaceInfo: null,\r\n      hexbinInfo: {},\r\n      gisInfo: {},\r\n      demoMode: false, // display collapsed UI demo mode\r\n      feature: null,\r\n      featureProp: null,\r\n      featurePropValue: '',\r\n      featurePropCount: null,\r\n      featurePropValueCounts: null,\r\n      featurePropValueSort: 'count',\r\n      featurePropNumericThreshold: 80, // minimum % of values that must be numeric to support range, etc.\r\n      featurePropCheckNumeric: null, // the property name that was active when we last checked for numeric-ness\r\n      featurePropPaletteName: 'viridis', // TODO: move palette to import\r\n      featurePropPaletteFlip: false,\r\n      featurePropMin: null,\r\n      featurePropMax: null,\r\n      featurePropMinFilterInput: '', // use empty string to get input placeholder\r\n      featurePropMaxFilterInput: '', // use empty string to get input placeholder\r\n      featurePropMean: null,\r\n      featurePropMedian: null,\r\n      featurePropStdDev: null,\r\n      featurePropSigma: null,\r\n      featurePropSigmaFloor: null,\r\n      featurePropSigmaCeiling: null,\r\n      featurePointSizeDisplayRange: [4, 20],\r\n      featurePointSizeProp: '', // setting this to null breaks the point toggle\r\n      \r\n      // these are params\r\n//       clustering: null,\r\n//       quadCountmode: null,\r\n//       quadRez: 4,\r\n//       voronoi: 'off',\r\n      \r\n\r\n      tagsWithCountsInViewport: [],\r\n      tagFilterList: [],\r\n      tagFilterAndOr: 'or',\r\n      tagFilterViewport: false,\r\n      tagFilterAt: false,\r\n      tagSort: 'count',\r\n      tagFilterSearch: '', // set these to empty strings (not null) to get placeholder text in input\r\n      propertySearch: {},\r\n      propertySearchOverride: null,\r\n\r\n      featuresInViewport: [],\r\n      featurePropTypesCache: {}, // cache of inferred feature property types\r\n      uniqueTagsSeen: new Set(),\r\n\r\n      uniqueFeaturePropsSeen: new Map(),\r\n\r\n      displayToggles: null,\r\n      vizModes, // need to reference here to make accessible to templates and tangram functions\r\n      colorPalettes, // need to reference here to make accessible to templates and tangram functions\r\n      vizHelpers, // need to reference here to make accessible to templates and tangram functions\r\n      basemaps, // need to reference here to make accessible to templates\r\n      projections, // need to reference here to make accessible to templates\r\n      isProjectable, // needa to reference here to make accessible to templates\r\n    }\r\n  },\r\n\r\n  components: {\r\n    FeaturePropHistogram: './FeaturePropHistogram.svelte',\r\n    FeaturePropTopValues: './FeaturePropTopValues.svelte',\r\n    FeaturePopup: './FeaturePopup.svelte',\r\n    PropertySearchList: './PropertySearchList.svelte'\r\n  },\r\n\r\n  computed: {\r\n    basemapScene: ({ basemap, projection }) => {\r\n      if (!isProjectable(basemap)) {\r\n        projection = getDefaultProjectionName();\r\n      }\r\n      const scene = getBasemapScene(basemap, projection);\r\n      if (scene) {\r\n        scene.global = {\r\n          ...scene.global,\r\n          vizModes\r\n        };\r\n      }\r\n      return scene;\r\n    },\r\n\r\n    // apply range filters if needed\r\n    featurePropMinFilter: ({ displayToggles, featurePropMin, featurePropMinFilterInput }) => {\r\n      // only use if color mode supports range filter\r\n      if (displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\r\n        const val = parseNumber(featurePropMinFilterInput);\r\n        if (typeof val === 'number' && !isNaN(val)) {\r\n          return val;\r\n        }\r\n      }\r\n      return featurePropMin;\r\n    },\r\n\r\n    featurePropMaxFilter: ({ displayToggles, featurePropMax, featurePropMaxFilterInput }) => {\r\n      // only use if color mode supports range filter\r\n      if (displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\r\n        const val = parseNumber(featurePropMaxFilterInput);\r\n        if (typeof val === 'number' && !isNaN(val)) {\r\n          return val;\r\n        }\r\n      }\r\n      return featurePropMax;\r\n    },\r\n\r\n    featurePropRows: ({ feature }) => feature && parseNestedObject(feature.properties),\r\n\r\n    featurePropPalette: ({ featurePropPaletteName }) => {\r\n      return colorPalettes[featurePropPaletteName];\r\n    },\r\n\r\n    // update stats for current features and point size property (if one selected)\r\n    featurePointSizePropStats: ({ featuresInViewport, featurePointSizeProp }) => {\r\n      return calcFeaturePropertyStats(featuresInViewport, featurePointSizeProp);\r\n    },\r\n\r\n    // how point sizes are mapped to feature property values\r\n    featurePointSizeRange: ({ featurePointSizePropStats, featurePointSizeDisplayRange }) => {\r\n      return [\r\n        // value range for features in viewport\r\n        featurePointSizePropStats.min, featurePointSizePropStats.max,\r\n        // pixel size range to map these to\r\n        parseFloat(featurePointSizeDisplayRange[0]) || 5, parseFloat(featurePointSizeDisplayRange[1]) || 20\r\n      ];\r\n    },\r\n\r\n    sortedFeaturePropValueCounts: ({ featurePropValueCounts, featurePropValueSort }) => {\r\n      if (!featurePropValueCounts) {\r\n        return [];\r\n      }\r\n\r\n      if (featurePropValueSort === 'values') {\r\n        // copy and re-sort on value (descending) if needed\r\n        return Array.from(featurePropValueCounts).sort((a, b) => {\r\n          // try to get a number\r\n          let an = parseNumber(a[0]);\r\n          let bn = parseNumber(b[0]);\r\n\r\n          // sort nulls and NaNs to the bottom\r\n          an = (an == null || isNaN(an)) ? -Infinity : an;\r\n          bn = (bn == null || isNaN(bn)) ? -Infinity : bn;\r\n\r\n          return bn - an; // descending sort\r\n        });\r\n      }\r\n      return featurePropValueCounts; // return original/unmodified values\r\n    },\r\n\r\n    // function to calculate color for a feature prop value, based on current selection state\r\n    featurePropValueColorFunction: ({\r\n      displayToggles,\r\n      featurePropMinFilter, featurePropMaxFilter,\r\n      featurePropPalette, featurePropPaletteFlip, featurePropValueCounts, vizHelpers }) => {\r\n\r\n      return (value) => {\r\n        const vizMode = displayToggles.vizMode;\r\n        if (vizModes[vizMode] && vizModes[vizMode].color) {\r\n          return vizModes[vizMode].color(\r\n            value, {\r\n              displayToggles,\r\n              featurePropMinFilter, featurePropMaxFilter,\r\n              featurePropPalette, featurePropPaletteFlip, featurePropValueCounts,\r\n              vizHelpers\r\n            }\r\n          );\r\n        }\r\n        return 'rgba(127, 127, 127, .25)'; // color for null values?\r\n\r\n      };\r\n    },\r\n\r\n    featurePropMostlyNumeric: ({ featureProp, featurePropTypesCache, featuresInViewport, featurePropNumericThreshold }) => {\r\n      return isPropNumeric(featureProp, { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold });\r\n    },\r\n\r\n    featurePropValueCountHash: ({ featurePropValueCounts }) => featurePropValueCounts && hashString(JSON.stringify(featurePropValueCounts)),\r\n\r\n    nextTagSort: ({ tagSort }) => (tagSort === 'count' ? 'name' : 'count'),\r\n\r\n    tagsWithCountsInViewport: ({ featuresInViewport }) => {\r\n      // grab the tags from Tangram's viewport tiles\r\n      let tagsViewport = [];\r\n      featuresInViewport.forEach(x => {\r\n        if (x.properties['@ns:com:here:xyz'] && x.properties['@ns:com:here:xyz'].tags) {\r\n          tagsViewport.push(...x.properties['@ns:com:here:xyz'].tags);\r\n        }\r\n      })\r\n\r\n      const tagsWithCountsInViewport =\r\n        Object.entries(\r\n          featuresInViewport\r\n            .filter(f => f.properties['@ns:com:here:xyz'] && f.properties['@ns:com:here:xyz'].tags)\r\n            .flatMap(f => f.properties['@ns:com:here:xyz'].tags)\r\n            .reduce((tagCounts, tag) => {\r\n                tagCounts[tag] = tagCounts[tag] ? tagCounts[tag] + 1 : 1;\r\n                return tagCounts;\r\n              }, {}))\r\n        .sort((a, b) => b[1] > a[1] ? 1 : (b[1] > a[1] ? -1 : 0));\r\n      return tagsWithCountsInViewport;\r\n    },\r\n\r\n    uniqueTagsInViewport: ({ tagsWithCountsInViewport }) => new Set(tagsWithCountsInViewport.map(v => v[0])),\r\n\r\n    sortedUniqueFeaturePropsSeen: ({ uniqueFeaturePropsSeen }) => {\r\n      // alphabetical sort, but with @ properties at bottom\r\n      return Array.from(uniqueFeaturePropsSeen.keys())\r\n        .sort((a, b) => a[0] === '@' ? 1 : b[0] === '@' ? -1 : a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0)\r\n        .map(prop => [prop, uniqueFeaturePropsSeen.get(prop)]);\r\n    },\r\n\r\n    numFeatureTagsInViewport: ({ tagsWithCountsInViewport }) => tagsWithCountsInViewport.reduce((acc, cur) => acc + cur[1], 0),\r\n\r\n    // build the list of tags for display with checkboxes\r\n    tagDisplayList: ({ tagsWithCountsInViewport, tagSort, tagFilterList, tagFilterViewport, tagFilterAt, tagFilterSearch, uniqueTagsSeen }) => {\r\n      const tagCountMap = new Map();\r\n\r\n      // optional filters\r\n      // e.g. remove tags without an @ if desired, or text search\r\n      const tagFilterFunc = tag => {\r\n        const at = tagFilterAt ? tag.includes('@') : true;\r\n        const search = (tagFilterSearch && tagFilterSearch.length >= 3) ? tag.includes(tagFilterSearch) : true;\r\n        return (at && search) || tagFilterList.indexOf(tag) > -1; // always include selected tags\r\n      };\r\n\r\n      // add any tags that are selected, but not currently in the viewport\r\n      // this also handles cases where an impossible tag combo is selected (postcode 98125 AND postcode 98122),\r\n      // but we want those tags to still show up in the list so they can be de-selected\r\n      // note this ignores filters to ensure these tags can always be seen/de-selected\r\n      tagFilterList.forEach(tag => tagCountMap.set(tag, 0));\r\n\r\n      // add all uniquely seen tags that aren't currently in the viewport\r\n      if (!tagFilterViewport) {\r\n        uniqueTagsSeen\r\n          .forEach(tag => {\r\n            if (tagFilterFunc(tag)) {\r\n              tagCountMap.set(tag, 0);\r\n            }\r\n          });\r\n      }\r\n\r\n      // add tags currently in the viewport\r\n      tagsWithCountsInViewport\r\n        .filter(([tag]) => tagFilterFunc(tag))\r\n        .forEach(([tag, count]) => tagCountMap.set(tag, count));\r\n\r\n      // convert to array entries for sorting\r\n      let tagCounts = [...tagCountMap.entries()];\r\n\r\n      // sort tags as desired\r\n      if (tagSort === 'name') {\r\n        tagCounts.sort((a, b) => {\r\n          if (a[0] === b[0]) {\r\n            return a[1] < b[1] ? 1 : -1;\r\n          }\r\n          return a[0] < b[0] ? 1 : (a[0] > b[0] ? -1 : 0);\r\n        });\r\n      }\r\n      else if (tagSort === 'count') {\r\n        tagCounts.sort((a, b) => {\r\n          if (a[1] === b[1]) {\r\n            return a[0] < b[0] ? 1 : (a[0] > b[0] ? -1 : 0);\r\n          }\r\n          return a[1] < b[1] ? 1 : -1;\r\n        });\r\n      }\r\n\r\n      return tagCounts;\r\n    },\r\n\r\n    // format selected tags as a query parameter for XYZ tile requests\r\n    tagFilterQueryParam: ({ tagFilterList, tagFilterAndOr }) => {\r\n      if (tagFilterList.length === 0) {\r\n        return null;\r\n      }\r\n\r\n      if (tagFilterAndOr === 'and') {\r\n        return tagFilterList.join('+');\r\n      }\r\n      else {\r\n        return tagFilterList.join(',');\r\n      }\r\n    },\r\n\r\n    // format property searches as query parameters for XYZ tile requests\r\n    propertySearchQueryParams: ({ propertySearch }) => {\r\n      return Object.entries(propertySearch)\r\n        .reduce((params, [prop, { op, equals, min, max }]) => {\r\n          const p = `p.${prop}`;\r\n          if (op === 'equals' && equals) {\r\n            params.push([p, equals]);\r\n          }\r\n          else if (op === 'range') {\r\n            min = parseFloat(min);\r\n            max = parseFloat(max);\r\n\r\n            if (typeof min === 'number' && !isNaN(min)) {\r\n              params.push([p, `gt=${min}`]);\r\n            }\r\n\r\n            if (typeof max === 'number' && !isNaN(max)) {\r\n              params.push([p, `lt=${max}`]);\r\n            }\r\n          }\r\n          return params;\r\n        }, []);\r\n    },\r\n\r\n    queryParams: ({\r\n        spaceId, token, basemap, projection,\r\n        demoMode,\r\n        displayToggles,\r\n        featureProp,\r\n        featurePropValue,\r\n        featurePropPaletteName, featurePropPaletteFlip,\r\n        featurePropRangeFilter,\r\n        featurePropMinFilterInput,\r\n        featurePropMaxFilterInput,\r\n        featurePropValueSort,\r\n        featurePropHideOutliers,\r\n        featurePointSizeProp,\r\n        featurePointSizeDisplayRange,\r\n        tagFilterQueryParam,\r\n        propertySearch\r\n      }) => {\r\n\r\n      const params = new URLSearchParams();\r\n\r\n      if (spaceId) {\r\n        params.set('space', spaceId);\r\n      }\r\n\r\n      if (token) {\r\n        params.set('token', token);\r\n      }\r\n\r\n      params.set('basemap', basemap);\r\n\r\n      params.set('projection', projection);\r\n\r\n      params.set('demo', demoMode ? 1 : 0);\r\n\r\n      for(const p in displayToggles) {\r\n        if (displayToggles[p] != null) {\r\n          params.set(p, displayToggles[p]);\r\n        }\r\n      }\r\n\r\n      if (tagFilterQueryParam) {\r\n        params.set('tags', tagFilterQueryParam);\r\n      }\r\n\r\n      if (featureProp) {\r\n        params.set('property', featureProp);\r\n      }\r\n\r\n      if (featurePropValue) {\r\n        params.set('value', featurePropValue);\r\n      }\r\n\r\n      params.set('palette', featurePropPaletteName);\r\n      params.set('paletteFlip', featurePropPaletteFlip);\r\n\r\n      // save range filter (if current color mode supports it)\r\n      if (featurePropRangeFilter && displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\r\n        params.set('rangeFilter', featurePropRangeFilter);\r\n        if (featurePropRangeFilter === 'custom') {\r\n          params.set('rangeFilterMin', featurePropMinFilterInput);\r\n          params.set('rangeFilterMax', featurePropMaxFilterInput);\r\n        }\r\n      }\r\n\r\n      params.set('sort', featurePropValueSort);\r\n      params.set('hideOutliers', featurePropHideOutliers);\r\n\r\n      params.set('pointSizeProp', featurePointSizeProp);\r\n      params.set('pointSizeRange', JSON.stringify(featurePointSizeDisplayRange));\r\n\r\n      params.set('propertySearch', JSON.stringify(propertySearch));\r\n\r\n      return params;\r\n    }\r\n\r\n  },\r\n\r\n  onstate({ changed, current, previous }) {\r\n    // update globally seen tags\r\n    if (changed.uniqueTagsInViewport) {\r\n      this.set({\r\n        uniqueTagsSeen: new Set([...current.uniqueTagsSeen, ...current.uniqueTagsInViewport].filter(x => x))\r\n      });\r\n    }\r\n\r\n    // check if globally seen properties need to be updated\r\n    const uniqueFeaturePropsSeen = new Map(current.uniqueFeaturePropsSeen); // get currently known props\r\n    let updateUniqueFeaturePropsSeen = false;\r\n\r\n    // seed globally seen properties from space stats\r\n    if (changed.spaceInfo && current.spaceInfo) {\r\n\r\n      Object.entries(current.spaceInfo.properties)\r\n        .forEach(([prop, value]) => {\r\n          const propStack = prop.split(':'); // XYZ API uses ':' delimiter\r\n          prop = formatPropStack(propStack);\r\n          uniqueFeaturePropsSeen.set(prop, {\r\n            ...value,\r\n            propStack\r\n          });\r\n        });\r\n      updateUniqueFeaturePropsSeen = true;\r\n    }\r\n\r\n    // update globally seen properties from current feature set\r\n    if (changed.featuresInViewport) {\r\n      current.featuresInViewport.forEach(feature => {\r\n        parseNestedObject(feature.properties)\r\n          .filter(p => !p.prop.startsWith('$')) // don't include special tangram context properties\r\n          .filter(p => !uniqueFeaturePropsSeen.has(p.prop)) // skip properties we already know about\r\n          .forEach(p => {\r\n            uniqueFeaturePropsSeen.set(p.prop, { propStack: p.propStack }); // add new props\r\n          });\r\n      });\r\n      updateUniqueFeaturePropsSeen = true;\r\n\r\n      // reset property type cache (re-evaluatate property types when new features are available)\r\n      this.set({ featurePropTypesCache: {} });\r\n    }\r\n\r\n    // update feature props if needed\r\n    if (updateUniqueFeaturePropsSeen) {\r\n      this.set({ uniqueFeaturePropsSeen });\r\n    }\r\n\r\n    // Apply Tangram scene updates based on state change\r\n    if (current.spaceInfo &&\r\n        (changed.basemapScene || changed.spaceInfo || changed.projection)) {\r\n      this.fire('loadScene', current);\r\n    }\r\n\r\n    if (changed.displayToggles ||\r\n        changed.tagFilterQueryParam ||\r\n        changed.propertySearchQueryParams ||\r\n        changed.hexbinInfo ||\r\n        changed.gisInfo ||\r\n        changed.featureProp ||\r\n        changed.featurePropValue ||\r\n        changed.featurePointSizeProp ||\r\n        changed.featurePointSizeDisplayRange ||\r\n        changed.featurePropPalette ||\r\n        changed.featurePropPaletteFlip ||\r\n        changed.featurePropValueCountHash ||\r\n        changed.featurePropMinFilter ||\r\n        changed.featurePropMaxFilter ||\r\n        changed.featurePropHideOutliers) {\r\n      this.fire('updateScene', current);\r\n    }\r\n\r\n    // mark space as loaded\r\n    // used to hide UI during load (maybe replace with promise)\r\n    if (changed.spaceInfo && current.spaceInfo) {\r\n      this.set({\r\n        spaceLoading: false\r\n      });\r\n    }\r\n\r\n    // update query string as needed\r\n    if (changed.queryParams) {\r\n      this.fire('updateQueryString', current);\r\n    }\r\n  },\r\n\r\n  onupdate({ changed, current, previous }) {\r\n    // note: svelte needs these checks in onupdate instead of onstate because of interdependencies when\r\n    // calling a set() from inside onstate that triggers another set(); these issues are reportedly fixed in v3,\r\n    // separating this check out into onupdate for now\r\n\r\n    // reset range filter to 'all' when selected property changes\r\n    if (changed.featureProp && previous && previous.featureProp && current.featurePropRangeFilter === 'custom') {\r\n      this.updateFeaturePropRangeFilter(0); // zero = use all values / no range limiting\r\n    }\r\n    // update range filter when underlying data changes\r\n    else if (changed.featurePropMin || changed.featurePropMax) {\r\n      this.updateFeaturePropRangeFilter();\r\n    }\r\n\r\n    // additional checks when feature property values update\r\n    if (changed.featurePropValueCountHash &&\r\n        current.displayToggles != null &&\r\n        current.featurePropCheckNumeric !== current.featureProp) {\r\n\r\n        // if color 'range' mode is active, check if values are sufficiently numeric, and if so,\r\n        // automatically switch to 'rank' mode instead (no use using range controls for non-numeric data)\r\n        let vizMode = current.displayToggles.vizMode;\r\n        if (!current.featurePropMostlyNumeric && vizMode === 'range') {\r\n          vizMode = 'rank';\r\n        }\r\n        // or the converse\r\n        else if (current.featurePropMostlyNumeric && vizMode === 'rank') {\r\n          vizMode = 'range';\r\n        }\r\n\r\n        this.set({\r\n          featurePropCheckNumeric: current.featureProp, // record that we last ran the check for this property name\r\n          displayToggles: { ...current.displayToggles, vizMode }\r\n        });\r\n        this.updateFeaturePropValueSort();\r\n    }\r\n\r\n    // tell map to update popup content when it changes\r\n    // (this is in svelte onupdate because it fires after the DOM has been updated with new content)\r\n    if (changed.feature ||\r\n        changed.featureProp ||\r\n        changed.featureProp ||\r\n        changed.featurePinned) {\r\n      if (current.feature) {\r\n        this.fire('updatePopup');\r\n      }\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    setFromQueryParams(params) {\r\n      // convert query params to object\r\n      params = [...params.entries()].reduce((p, [k, v]) => { p[k] = v; return p; }, {});\r\n\r\n      // set these to empty strings (not null) to get placeholder text in input\r\n      const spaceId = params.space || '';\r\n      const token = '';\r\n      const demoMode = (parseInt(params.demo) === 1);\r\n\r\n      // parse out display option toggles\r\n      const displayToggles = {};\r\n      params.vizMode = params.vizMode || params.colors; // backwards compatibility for `colors` parameter\r\n      for (const p in params) {\r\n        if (displayOptions[p]) {\r\n          if (displayOptions[p].parse) {\r\n            // parse display options values (e.g. convert strings to numbers, etc.)\r\n            displayToggles[p] = displayOptions[p].parse(params[p]);\r\n          }\r\n          else if (params[p] !== 'null' && params[p] !== 'undefined') {\r\n            displayToggles[p] = params[p];\r\n          }\r\n        }\r\n      }\r\n\r\n      // set default values for display options\r\n      for (const p in displayOptions) {\r\n        if (displayToggles[p] == null) {\r\n          displayToggles[p] = defaultDisplayOptionValue(p);\r\n        }\r\n      }\r\n\r\n      // parse tags\r\n      let tagFilterList = [];\r\n      let tagFilterAndOr = this.get().tagFilterAndOr;\r\n      if (params.tags) {\r\n        // look for OR tags\r\n        if (params.tags.includes(',')) {\r\n          tagFilterList = params.tags.split(',');\r\n          tagFilterAndOr = 'or';\r\n        }\r\n        // look for AND tags\r\n        // if (params.tags.includes('+')) {\r\n        else {\r\n          tagFilterList = params.tags.split('+');\r\n          tagFilterAndOr = 'and';\r\n        }\r\n      }\r\n\r\n      let basemap = getBasemapName(params.basemap);\r\n      if (!getBasemapScene(basemap) || !params.basemap) { // check for no parameter\r\n        basemap = getDefaultBasemapName();\r\n      }\r\n      let projectable = isProjectable(basemap);\r\n\r\n      let projection = params.projection;\r\n      if (!getProjectionScene(projection) || !projectable) {\r\n        projection = getDefaultProjectionName();\r\n      }\r\n\r\n      // parse selected feature property\r\n      const featureProp = params.property;\r\n\r\n      // parse selected property value\r\n      let featurePropValue = params.value === undefined ? '' : params.value;\r\n      if (featurePropValue && featurePropValue.match(/^\\d+$/)) {\r\n        featurePropValue = parseNumber(featurePropValue); // parse from string if needed\r\n      }\r\n\r\n      // parse color palette\r\n      const featurePropPaletteFlip = (params.paletteFlip === 'true');\r\n      let featurePropPaletteName = this.get().featurePropPaletteName;\r\n      if (colorPalettes[params.palette]) {\r\n        featurePropPaletteName = params.palette;\r\n      }\r\n\r\n      // parse min/max range filter\r\n      const featurePropRangeFilter = params.rangeFilter;\r\n      let { featurePropMinFilterInput, featurePropMaxFilterInput } = this.get();\r\n      if (featurePropRangeFilter === 'custom') {\r\n        featurePropMinFilterInput = params.rangeFilterMin;\r\n        featurePropMaxFilterInput = params.rangeFilterMax;\r\n      }\r\n\r\n      const featurePropValueSort = params.sort || 'count';\r\n      const featurePropHideOutliers = (params.hideOutliers === 'true');\r\n\r\n      const featurePointSizeProp = params.pointSizeProp || '';\r\n      let featurePointSizeDisplayRange = this.get().featurePointSizeDisplayRange;\r\n      try { // protect against JSON.parse failure (it's brittle with string input)\r\n        featurePointSizeDisplayRange = JSON.parse(params.pointSizeRange);\r\n      } catch(e) {}\r\n\r\n      let propertySearch = {};\r\n      try { // protect against JSON.parse failure (it's brittle with string input)\r\n        propertySearch = JSON.parse(params.propertySearch);\r\n      } catch(e) {}\r\n\r\n      // set all params\r\n      this.set({\r\n        spaceId,\r\n        token,\r\n        basemap,\r\n        projection,\r\n        demoMode,\r\n        displayToggles,\r\n        featureProp,\r\n        featurePropValue,\r\n        featurePropPaletteName,\r\n        featurePropPaletteFlip,\r\n        featurePropRangeFilter,\r\n        featurePropMinFilterInput,\r\n        featurePropMaxFilterInput,\r\n        featurePropValueSort,\r\n        featurePropHideOutliers,\r\n        featurePointSizeProp,\r\n        featurePointSizeDisplayRange,\r\n        tagFilterList,\r\n        tagFilterAndOr,\r\n        propertySearch\r\n      });\r\n\r\n      this.updateSpace(false);\r\n      this.updateFeaturePropRangeFilter();\r\n      if (featurePropValueSort == null) {\r\n        this.updateFeaturePropValueSort();\r\n      }\r\n    },\r\n\r\n    updateSpace(loadScene) {\r\n      const { spaceId, token, basemapScene } = this.get();\r\n\r\n      if (spaceId ) {\r\n        this.set({\r\n          spaceLoading: true, // used to hide UI during load (maybe replace with promise)\r\n          uniqueTagsSeen: new Set() // reset unique tags when loading new space\r\n        });\r\n\r\n        this.fire('loadSpace', {\r\n          spaceId,\r\n          token\r\n        });\r\n\r\n        if (loadScene) {\r\n          this.fire('loadScene', {\r\n            basemapScene\r\n          });\r\n        }\r\n      }\r\n    },\r\n\r\n    setFeatureProp({ featureProp, featurePropValue }) {\r\n      // if selecting a feature property and current color mode isn't property-specific,\r\n      // automatically change to the 'property' color mode\r\n      const displayToggles = this.get().displayToggles;\r\n      let vizMode = displayToggles.vizMode;\r\n      if (vizModes[vizMode] && !vizModes[vizMode].useProperty) {\r\n        vizMode = 'property';\r\n      }\r\n\r\n      this.set({\r\n        featureProp,\r\n        featurePropValue,\r\n        displayToggles: { ...displayToggles, vizMode }\r\n      });\r\n    },\r\n\r\n    updateFeaturePropValueSort() {\r\n      // set default sort type (if there is one) for feature property color mode\r\n      const displayToggles = this.get().displayToggles;\r\n      let vizMode = displayToggles.vizMode;\r\n      if (vizModes[vizMode] && vizModes[vizMode].defaultSort) {\r\n        this.set({ featurePropValueSort: vizModes[vizMode].defaultSort });\r\n      }\r\n    },\r\n\r\n    updateFeaturePropRangeFilter(filter = null) {\r\n      const {\r\n        featurePropRangeFilter,\r\n        featurePropMin,\r\n        featurePropMax,\r\n        featurePropMean,\r\n        featurePropStdDev\r\n      } = this.get();\r\n\r\n      // update filter type if one specified, or keep existing\r\n      if (filter == null) {\r\n        filter = featurePropRangeFilter; // use existing filter\r\n      }\r\n      else {\r\n        this.set({\r\n          featurePropRangeFilter: filter.toString() // set new filter\r\n        });\r\n      }\r\n\r\n      // derive min/max values if needed (values specified manually in custom mode)\r\n      if (filter !== 'custom') {\r\n        const sigmaFilter = parseInt(filter);\r\n\r\n        if (typeof sigmaFilter === 'number' && sigmaFilter > 0 &&\r\n            featurePropMin != null && featurePropMax != null) { // require a min/max to be set\r\n          const min = Math.max(featurePropMin, parseFloat((featurePropMean - (featurePropStdDev * sigmaFilter)).toFixed(2)));\r\n          const max = Math.min(featurePropMax, parseFloat((featurePropMean + (featurePropStdDev * sigmaFilter)).toFixed(2)));\r\n\r\n          this.set({\r\n            featurePropMinFilterInput: min, featurePropMaxFilterInput: max\r\n          });\r\n        }\r\n        else { // no filter / \"all\"\r\n          this.set({\r\n            featurePropMinFilterInput: featurePropMin, featurePropMaxFilterInput: featurePropMax\r\n          });\r\n        }\r\n      }\r\n    },\r\n\r\n    toggleDisplayOption(prop) {\r\n      const displayToggles = this.get().displayToggles;\r\n\r\n      const vals = displayOptions[prop] && displayOptions[prop].values;\r\n      if (vals) {\r\n        const i = vals.indexOf(displayToggles[prop]);\r\n        if (i > -1) {\r\n          displayToggles[prop] = vals[(i + 1) % vals.length];\r\n        }\r\n        else {\r\n          displayToggles[prop] = vals[0];\r\n        }\r\n      }\r\n\r\n      this.set({ displayToggles });\r\n    },\r\n\r\n    toggleTagSort() {\r\n      this.set({ tagSort: this.get().nextTagSort });\r\n    },\r\n\r\n    toggleTagFilterViewport() {\r\n      this.set({ tagFilterViewport: !this.get().tagFilterViewport })\r\n    },\r\n\r\n    toggleTagFilterAt() {\r\n      this.set({ tagFilterAt: !this.get().tagFilterAt })\r\n    },\r\n\r\n    handleKeyPress({ key }) {\r\n      // b = toggle buildings\r\n      // l = line width\r\n      // n = names on map\r\n      // o = toggle polygon outlines\r\n      // p = make dots bigger\r\n      // r = toggle roads\r\n      // s = make dots smaller and lines narrower\r\n      // w = put polygons under water\r\n\r\n      if (key == \"m\") { // toggle basemap\r\n        this.set({ basemap: getNextBasemap(this.get().basemap) });\r\n      }\r\n      else {\r\n        if (key == \"b\") { // toggle buildings\r\n          this.toggleDisplayOption('buildings');\r\n        }\r\n        else if (key == \"l\") { // make lines smaller\r\n          this.toggleDisplayOption('lines');\r\n        }\r\n        else if (key == \"n\") { // hide places\r\n          this.toggleDisplayOption('places');\r\n        }\r\n        else if (key == \"o\") { // toggle outlines\r\n          this.toggleDisplayOption('outlines');\r\n        }\r\n        else if (key == \"p\") { // change point size\r\n          this.toggleDisplayOption('points');\r\n        }\r\n        else if (key == \"v\") { // toggle roads -- v for via! (changed from r because of cmd-r reload)\r\n          this.toggleDisplayOption('roads');\r\n        }\r\n        else if (key == \"w\") { // put polygons under water\r\n          this.toggleDisplayOption('water');\r\n        }\r\n        else if (key == \"x\") { // toggle hexbins, centroids, (and raw data?)\r\n          this.toggleDisplayOption('hexbins');\r\n        }\r\n        else if (key == \"k\") { // toggle server-side clustering\r\n          this.toggleDisplayOption('clustering');\r\n        }        \r\n      }\r\n    }\r\n\r\n  },\r\n\r\n  helpers: {\r\n    vizModeUsesProperty(mode) {\r\n      return vizModes[mode] && vizModes[mode].useProperty;\r\n    },\r\n\r\n    showFeaturePropPalette(mode) {\r\n      return vizModes[mode] && vizModes[mode].usePalette;\r\n    },\r\n\r\n    patternOptions: displayOptions.pattern.values, // for easier template access\r\n\r\n    // references here make these available to as template helper\r\n    useFeaturePropRangeLimit,\r\n    // isPropNumeric\r\n  }\r\n}\r\n\r\n// calculate whether a property is numeric based on the current features in the viewport, and cache the result\r\nfunction isPropNumeric(prop, { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold }) {\r\n  const propStack = parsePropStack(prop);\r\n  if (featurePropTypesCache[prop] == null) {\r\n    // use a set to get unique values from array\r\n    const propValues = new Set(featuresInViewport\r\n      .map(f => lookupProperty(f.properties, propStack))\r\n      .filter(f => typeof f !== 'object')\r\n    );\r\n    featurePropTypesCache[prop] =\r\n      mostlyNumeric([...propValues], featurePropNumericThreshold) ? PROP_TYPES.NUMERIC : PROP_TYPES.STRING;\r\n  }\r\n  return featurePropTypesCache[prop] === PROP_TYPES.NUMERIC;\r\n}\r\n\r\nfunction useFeaturePropRangeLimit(vizMode) {\r\n  return vizModes[vizMode] && vizModes[vizMode].limitRange;\r\n}\r\n\r\nfunction formatFeaturePropValueColor(state, value) {\r\n  const vizMode = state.displayToggles.vizMode;\r\n  if (vizModes[vizMode] && vizModes[vizMode].color) {\r\n    return vizModes[vizMode].color(value, state);\r\n  }\r\n  return 'rgba(127, 127, 127, .25)';\r\n}\r\n\r\nfunction hashString (string) {\r\n    var hash = 0, i, chr, len;\r\n\r\n    if (string.length === 0) {\r\n        return hash;\r\n    }\r\n\r\n    for (i = 0, len = string.length; i < len; i++) {\r\n        chr   = string.charCodeAt(i);\r\n        hash  = ((hash << 5) - hash) + chr;\r\n        hash |= 0; // Convert to 32bit integer\r\n    }\r\n    return hash;\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n  .column {\r\n    position: absolute;\r\n    z-index: 1000;\r\n    min-height: 100vh;\r\n    max-height: 100vh;\r\n    display: flex;\r\n    flex-direction: column;\r\n    width: 300px;\r\n  }\r\n\r\n  .panel {\r\n    margin: 5px;\r\n    padding: 5px;\r\n    background-color: rgba(200, 200, 200, 0.75);\r\n    border: 1px solid black;\r\n    border-radius: 3px;\r\n    color: black;\r\n    box-shadow: 2px 2px 2px black;\r\n  }\r\n\r\n  #space_info {\r\n    /* for long space descriptions */\r\n    /* overflow-x: auto; */\r\n    overflow-wrap: break-word;\r\n  }\r\n\r\n  #properties {\r\n    overflow: auto;\r\n    height: 150vh;\r\n    flex: 1 1 auto;\r\n  }\r\n\r\n  #properties table {\r\n    width: 100%;\r\n  }\r\n\r\n  #properties tr.active {\r\n    background-color: lightyellow;\r\n  }\r\n\r\n  #viz {\r\n    overflow: auto;\r\n    flex: 1 1 auto;\r\n    height: 20vh;\r\n  }\r\n\r\n  #controls_right {\r\n    right: 0;\r\n  }\r\n\r\n  .hideInDemoMode {\r\n    display: none !important;\r\n  }\r\n\r\n  #tag_panel {\r\n    overflow: auto;\r\n    flex: 1 1 150vh;\r\n  }\r\n\r\n  #tag_search {\r\n    width: calc(100% - 8px);\r\n    margin: 4px 0px;\r\n    padding: 2px;\r\n  }\r\n\r\n  .range_filter {\r\n    width: 45px;\r\n  }\r\n\r\n  .property_selector {\r\n    display: flex;\r\n    flex-direction: row;\r\n    align-items: center;\r\n    margin: 5px 0px;\r\n  }\r\n\r\n  .active {\r\n    background-color: lightyellow; padding: 3px;\r\n  }\r\n\r\n  .demoModeToggle {\r\n    /* position: absolute; */\r\n    /* right: 10px; */\r\n    /* top: 10px; */\r\n    /* z-index: 1001; */\r\n    float: right;\r\n  }\r\n\r\n  .controls_left_selector {\r\n    float: left;\r\n    clear: left;\r\n  }\r\n\r\n  .demoModeToggle {\r\n    /* position: absolute; */\r\n    /* right: 10px; */\r\n    /* top: 10px; */\r\n    /* z-index: 1001; */\r\n    float: right;\r\n  }\r\n\r\n  /* mobile styles at the end for higher precedence */\r\n\r\n  /* mobile (any orientation) */\r\n  @media (max-width: 960px) {\r\n    .hideOnMobile {\r\n      display: none;\r\n    }\r\n\r\n    /* columns are narrower */\r\n    .column {\r\n      width: 240px;\r\n    }\r\n\r\n    /* more button-like appearance on iOS */\r\n    button {\r\n      -webkit-appearance: textfield;\r\n    }\r\n  }\r\n\r\n  /* mobile in portrait */\r\n  @media (max-width: 960px) and (orientation: portrait) {\r\n    .hideOnMobilePortrait {\r\n      display: none;\r\n    }\r\n\r\n    /* left column fills whole screen */\r\n    #controls_left {\r\n      width: 100%;\r\n      /* unset flexbox full height that will block user input */\r\n      min-height: unset;\r\n      max-height: unset;\r\n    }\r\n  }\r\n\r\n  /* mobile in landscape */\r\n  @media (max-width: 960px) and (orientation: landscape) {\r\n    /* keep basemap and projection selectors from being too wide */\r\n    .controls_left_dropdown {\r\n      width: 110px;\r\n    }\r\n  }\r\n\r\n</style>\r\n",
    "{#if showHeader}\r\n  <div style=\"margin: 5px 0 5px 0;\">\r\n    Top values by\r\n    <select bind:value=\"valueSort\">\r\n      <option>count</option>\r\n      <option>values</option>\r\n    </select>\r\n  </div>\r\n{/if}\r\n\r\n<table>\r\n  <thead>\r\n    <tr><td style=\"text-align: right;\">#</td><td></td><td>Value</td></tr>\r\n  </thead>\r\n  <tbody>\r\n    {#each valueCounts.slice(0, 50) as [value, count], i }\r\n      <tr>\r\n        <td style=\"width: 15px; text-align: right;\">{count}</td>\r\n        <td style=\"width: 15px;\">\r\n          <!-- uses color calc code shared with tangram-->\r\n          {#if valueColorFunction}\r\n            <span class=\"dot\" style=\"background-color: {valueColorFunction(value)};\">\r\n            </span>\r\n          {/if}\r\n        </td>\r\n        <td\r\n          class=\"value_row\"\r\n          class:active=\"propValue != '' && value == propValue\"\r\n          on:click=\"set({propValue: (value != propValue ? value : '')})\">\r\n          {maybeStringifyObject(value)}\r\n        </td>\r\n      </tr>\r\n    {/each}\r\n  </tbody>\r\n</table>\r\n\r\n{#if valueCounts.length > 50}\r\n  <i>{valueCounts.length - 50} more {valueCounts.length - 50 > 1 ? 'values' : 'value'} for {prop} not shown</i>\r\n{/if}\r\n<script>\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      prop: null,\r\n      propValue: null,\r\n      valueSort: null,\r\n      valueCounts: [],\r\n      valueColorFunction: null,\r\n      showHeader: true\r\n    }\r\n  },\r\n\r\n  helpers: {\r\n    maybeStringifyObject(v) {\r\n      // stringify objects, otherwise just return original object\r\n      return (v != null && typeof v === 'object') ? JSON.stringify(v) : v;\r\n    }\r\n  }\r\n};\r\n\r\n</script>\r\n\r\n<style>\r\n\r\n.dot {\r\n  height: 11px;\r\n  width: 11px;\r\n  background-color: yellow;\r\n  border: 2px solid grey;\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n  vertical-align: bottom;\r\n}\r\n\r\n.active {\r\n  background-color: lightyellow; padding: 3px;\r\n}\r\n\r\n.value_row:hover {\r\n  background-color: rgba(240, 240, 240, 0.75);\r\n}\r\n\r\n</style>\r\n",
    "<style>\r\n\r\n.propRow > td {\r\n  padding: 2px;\r\n}\r\n\r\n.propRow > td:hover {\r\n  background-color: rgba(240, 240, 240, 0.75);\r\n  cursor: pointer;\r\n}\r\n\r\n.propRow > td.active {\r\n  background-color: lightyellow;\r\n}\r\n\r\n</style>\r\n\r\n<div style=\"{featurePinned ? 'height: 200px; overflow: auto;' : ''}\">\r\n  <table>\r\n\r\n  {#each summaryProps as [prop, value, propStack]}\r\n    <tr class=\"propRow\">\r\n      <td style=\"width: 50px;\" class:active=\"prop === featureProp\" on:click=\"fire('selectProp', { prop, propStack })\">\r\n        <b>{@html Array((propStack.length - 1) * 2).fill('&nbsp;').join('')}{propStack[propStack.length-1]}</b>\r\n      </td>\r\n      <td style=\"word-break: break-all;\" class:active=\"value === featurePropValue\" on:click=\"fire('selectValue', { prop, propStack, value })\">\r\n        {typeof value !== 'object' ? value : ''}\r\n      </td>\r\n    </tr>\r\n  {/each}\r\n\r\n  {#if extendedProps.length && summaryProps.length}\r\n    <tr><td colspan=\"2\"><hr></td></tr>\r\n  {/if}\r\n\r\n  {#each extendedProps as [prop, value, propStack]}\r\n    <tr class=\"propRow\">\r\n      <td style=\"width: 50px;\" class:active=\"prop === featureProp\" on:click=\"fire('selectProp', { prop, propStack })\">\r\n        <b>{@html Array((propStack.length - 1) * 2).fill('&nbsp;').join('')}{propStack[propStack.length-1]}</b>\r\n      </td>\r\n      <td style=\"word-break: break-all;\" class:active=\"value === featurePropValue\" on:click=\"fire('selectValue', { prop, propStack, value })\">\r\n        {typeof value !== 'object' ? value : ''}\r\n      </td>\r\n    </tr>\r\n  {/each}\r\n\r\n  {#if !featurePinned && feature}\r\n    <tr><td colspan=\"2\"><i>Click to see all {Object.keys(feature.properties).length} properties</i></td></tr>\r\n  {/if}\r\n</div>\r\n\r\n<script>\r\n\r\nimport { parsePropStack, parseNestedObject, lookupProperty } from './utils';\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      featurePinned: false\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    summaryProps: ({ feature, featureProp }) => {\r\n      if (feature == null) {\r\n        return [];\r\n      }\r\n\r\n      const featurePropStack = parsePropStack(featureProp);\r\n      const addFeatureProp = (['id', 'name', 'wof:name'].indexOf(featureProp) === -1);\r\n\r\n      return [\r\n          ['id', feature.properties.id, ['id']],\r\n          ['name', feature.properties.name, ['name']],\r\n          ['WOF name', feature.properties['wof:name'], ['wof:name']],\r\n          ['feature id', feature.id, ['feature id']],\r\n          addFeatureProp ? [featureProp, lookupProperty(feature.properties, featurePropStack) || 'null', featurePropStack] : []\r\n        ]\r\n        .filter(x => x[0] && x[1]); // only include props that had values\r\n    },\r\n\r\n    extendedProps: ({ feature, featureProp, featurePinned }) => {\r\n      if (!featurePinned || feature == null) {\r\n        return [];\r\n      }\r\n\r\n      return parseNestedObject(feature.properties)\r\n        .map(r => [r.prop, r.obj, r.propStack])\r\n        .filter(([p]) => ['id', 'name', 'wof:name'/*, featureProp*/].indexOf(p) === -1)\r\n        .filter(x => x[0] && x[1]) // only include props that had values\r\n        // alpha sort, @ properties at bottom\r\n        .sort(([a], [b]) => a[0] === '@' ? 1 : b[0] === '@' ? -1 : a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0);\r\n    }\r\n  }\r\n\r\n};\r\n\r\n</script>\r\n",
    "<style>\r\n\r\n.equals {\r\n  width: 70px;\r\n}\r\n\r\n.range {\r\n  width: 30px;\r\n}\r\n\r\n</style>\r\n\r\n<span>\r\n  <select bind:value=op>\r\n    <option value=\"\"></option>\r\n    <option value=\"equals\">equals</option>\r\n<!--     {#if datatype === 'number'} --> // removing this so we can sort things like 8601 dates\r\n      <option value=\"range\">range</option>\r\n<!--     {/if} -->\r\n  </select>\r\n</span>\r\n<span>\r\n  {#if op != null && op != ''}\r\n      {#if op === 'equals'}\r\n        <input\r\n          class=\"equals\" type=\"text\" placeholder=\"value(s)\"\r\n          on:keydown=\"event.stopPropagation()\"\r\n          bind:value=equals\r\n        >\r\n      {:elseif op === 'range'}\r\n        <input\r\n          class=\"range\" type=\"text\" placeholder=\"min\"\r\n          on:keydown=\"event.stopPropagation()\"\r\n          bind:value=min\r\n        >\r\n        <input\r\n          class=\"range\" type=\"text\" placeholder=\"max\"\r\n          on:keydown=\"event.stopPropagation()\"\r\n          bind:value=max\r\n        >\r\n      {/if}\r\n  {/if}\r\n</span>\r\n\r\n<script>\r\n\r\nimport _ from 'lodash';\r\n\r\n// number of milliseconds to delay input update events\r\nconst INPUT_DEBOUNCE_TIME = 500;\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      prop: null,\r\n      datatype: null,\r\n      initial: null,\r\n      op: null,\r\n      equals: '',\r\n      min: '',\r\n      max: ''\r\n    }\r\n  },\r\n\r\n  onstate({ changed, current, previous }) {\r\n    // first-time initialization with provided values\r\n    if (!previous && current.initial) {\r\n      const data = current.initial;\r\n      this.set({\r\n        op: data.op,\r\n        equals: data.equals != null ? data.equals : '',\r\n        min: data.min != null ? data.min : '',\r\n        max: data.max != null ? data.max : '',\r\n      });\r\n    }\r\n    // send updates to parent component\r\n    else if (changed.op || changed.equals || changed.min || changed.max) {\r\n      let { op, equals, min, max } = current;\r\n      const { datatype } = this.get();\r\n\r\n      // add explicit quotes to numeric searches on string fields\r\n      if (datatype === 'string' && equals != null && equals.match(/^\\d+$/)) {\r\n        equals = `\"${equals}\"`;\r\n      }\r\n\r\n      this.updateField({ prop: current.prop, values: { op, equals, min, max } });\r\n    }\r\n  },\r\n\r\n  methods: {\r\n\r\n    // debounced update event to avoid spamming on rapid UI changes\r\n    updateField: _.debounce(function({ prop, values }) {\r\n      this.fire('update', { prop, values });\r\n    }, INPUT_DEBOUNCE_TIME)\r\n\r\n  }\r\n\r\n};\r\n\r\n</script>\r\n"
  ],
  "names": [],
  "mappings": "AAs3CE,OAAO,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,KAAK,CACjB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,KAAK,AACd,CAAC,AAED,MAAM,eAAC,CAAC,AACN,MAAM,CAAE,GAAG,CACX,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAC3C,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,KAAK,CACvB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,AAC/B,CAAC,AAED,WAAW,eAAC,CAAC,AAGX,aAAa,CAAE,UAAU,AAC3B,CAAC,AAED,WAAW,eAAC,CAAC,AACX,QAAQ,CAAE,IAAI,CACd,MAAM,CAAE,KAAK,CACb,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,AAChB,CAAC,AAUD,IAAI,eAAC,CAAC,AACJ,QAAQ,CAAE,IAAI,CACd,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CACd,MAAM,CAAE,IAAI,AACd,CAAC,AAED,eAAe,eAAC,CAAC,AACf,KAAK,CAAE,CAAC,AACV,CAAC,AAED,eAAe,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAAC,UAAU,AAC1B,CAAC,AAED,UAAU,eAAC,CAAC,AACV,QAAQ,CAAE,IAAI,CACd,IAAI,CAAE,CAAC,CAAC,CAAC,CAAC,KAAK,AACjB,CAAC,AAED,WAAW,eAAC,CAAC,AACX,KAAK,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CACvB,MAAM,CAAE,GAAG,CAAC,GAAG,CACf,OAAO,CAAE,GAAG,AACd,CAAC,AAED,aAAa,eAAC,CAAC,AACb,KAAK,CAAE,IAAI,AACb,CAAC,AAED,kBAAkB,eAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,WAAW,CAAE,MAAM,CACnB,MAAM,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AAMD,eAAe,eAAC,CAAC,AAKf,KAAK,CAAE,KAAK,AACd,CAAC,AAED,uBAAuB,eAAC,CAAC,AACvB,KAAK,CAAE,IAAI,CACX,KAAK,CAAE,IAAI,AACb,CAAC,AAED,eAAe,eAAC,CAAC,AAKf,KAAK,CAAE,KAAK,AACd,CAAC,AAKD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,aAAa,eAAC,CAAC,AACb,OAAO,CAAE,IAAI,AACf,CAAC,AAGD,OAAO,eAAC,CAAC,AACP,KAAK,CAAE,KAAK,AACd,CAAC,AAGD,MAAM,eAAC,CAAC,AACN,kBAAkB,CAAE,SAAS,AAC/B,CAAC,AACH,CAAC,AAGD,MAAM,AAAC,YAAY,KAAK,CAAC,CAAC,GAAG,CAAC,cAAc,QAAQ,CAAC,AAAC,CAAC,AACrD,qBAAqB,eAAC,CAAC,AACrB,OAAO,CAAE,IAAI,AACf,CAAC,AAGD,cAAc,eAAC,CAAC,AACd,KAAK,CAAE,IAAI,CAEX,UAAU,CAAE,KAAK,CACjB,UAAU,CAAE,KAAK,AACnB,CAAC,AACH,CAAC,AAGD,MAAM,AAAC,YAAY,KAAK,CAAC,CAAC,GAAG,CAAC,cAAc,SAAS,CAAC,AAAC,CAAC,AAEtD,uBAAuB,eAAC,CAAC,AACvB,KAAK,CAAE,KAAK,AACd,CAAC,AACH,CAAC;ACl8CH,IAAI,eAAC,CAAC,AACJ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,MAAM,CACxB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,YAAY,CACrB,cAAc,CAAE,MAAM,AACxB,CAAC,AAED,OAAO,eAAC,CAAC,AACP,gBAAgB,CAAE,WAAW,CAAE,OAAO,CAAE,GAAG,AAC7C,CAAC,AAED,yBAAU,MAAM,AAAC,CAAC,AAChB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,AAC7C,CAAC;AC/ED,uBAAQ,CAAG,EAAE,eAAC,CAAC,AACb,OAAO,CAAE,GAAG,AACd,CAAC,AAED,uBAAQ,CAAG,iBAAE,MAAM,AAAC,CAAC,AACnB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAC3C,MAAM,CAAE,OAAO,AACjB,CAAC,AAED,uBAAQ,CAAG,EAAE,OAAO,eAAC,CAAC,AACpB,gBAAgB,CAAE,WAAW,AAC/B,CAAC;ACXD,OAAO,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,AACb,CAAC,AAED,MAAM,eAAC,CAAC,AACN,KAAK,CAAE,IAAI,AACb,CAAC"
}