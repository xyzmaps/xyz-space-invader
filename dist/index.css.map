{
  "version": 3,
  "file": "index.css",
  "sources": [
    "../AppUI.svelte",
    "../FeaturePropTopValues.svelte",
    "../FeaturePopup.svelte",
    "../PropertySearchField.svelte"
  ],
  "sourcesContent": [
    "<svelte:window on:keydown=\"handleKeyPress(event)\" />\n\n<!-- Render full UI -->\n<div id=\"controls_left\" class=\"column\">\n  <div id=\"spaces\" class=\"panel\">\n    <div id=\"space_info\">\n      {#if spaceInfo}\n        <div>\n          <!-- Demo/inspect mode toggle-->\n          <button on:click=\"set({ demoMode: !demoMode })\" class=\"demoModeToggle\">\n            {demoMode ? 'inspect' : 'demo'}\n          </button>\n\n          <!-- Space info -->\n          <div>{spaceInfo.title}</div>\n          {#if !demoMode}\n            <div>{spaceId}: {spaceInfo.numFeatures.toLocaleString()} features, {spaceInfo.dataSize}, {spaceInfo.featureSize}</div>\n            {#if spaceInfo.updatedAt}\n              <div>{spaceInfo.updatedAt}</div>\n            {/if}\n            <div style=\"font-size:10px;\">{spaceInfo.description}</div>\n          {/if}\n        </div>\n      {:elseif !spaceLoading}\n      <input type=\"text\" placeholder=\"XYZ API host url\" bind:value='hubApi'>\n      <input type=\"text\" placeholder=\"enter an XYZ space ID\" bind:value='spaceId'>\n        <button on:click=\"updateSpace(true)\">Show XYZ Space</button>\n      {/if}\n    </div>\n    <div id=\"style_info\" class:hideInDemoMode=\"demoMode\">\n      {#if displayToggles}\n        <table>\n          <tr>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"roads\")'>roads:</td>\n            <td>{displayToggles.roads}</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"buildings\")'>buildings:</td>\n            <td>{displayToggles.buildings}</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"water\")'>water:</td>\n            <td>{displayToggles.water}</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"places\")'>places:</td>\n            <td>{displayToggles.places}</td>\n          </tr>\n          <tr>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"points\")'>points:</td>\n            <td>{displayToggles.points}</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"lines\")'>lines:</td>\n            <td>{displayToggles.lines}</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"outlines\")'>outlines:</td>\n            <td>{displayToggles.outlines}</td>\n          </tr>\n        </table>\n        <table>\n          <tr>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"clustering\")'>clustering:</td>\n            {#if displayToggles.clustering == 0}\n            <td>\n<!--             {#if tokenCapabilities.hexbinClustering || tokenCapabilities.quadClustering} -->\n             off\n<!--             {:else} -->\n<!--              sign up for XYZ Pro to cluster -->\n<!--             {/if} -->\n            </td>\n            {/if}\n            {#if displayToggles.clustering == 1}\n            <td>H3 hexbins</td>\n            {/if}\n            {#if displayToggles.clustering == 2}\n            <td>H3 hexbin centroids</td>\n            {/if}\n            {#if displayToggles.clustering == 3}\n            <td>Quadbins</td>\n            <td style=\"color:blue;\" on:click='toggleDisplayOption(\"quadRez\")'>resolution:</td>\n            <td>{displayToggles.quadRez}</td>\n            {/if}\n          </tr>\n        </table>\n        \n        {#if gisInfo.voronoi || gisInfo.delaunay}\n        <table>\n          <tr>\n            <td>GIS:</td>\n            {#if gisInfo.voronoi}\n              <td style=\"color:blue;\" on:click='toggleDisplayOption(\"voronoi\")'>Voronoi:</td>\n              <td>\n              {#if displayToggles.voronoi == 0}\n              off\n              {/if}\n              {#if displayToggles.voronoi == 1}\n              {gisInfo.voronoi}\n              {/if}\n              </td>\n            {/if}\n            {#if gisInfo.delaunay}\n              <td style=\"color:blue;\" on:click='toggleDisplayOption(\"delaunay\")'>Delaunay:</td>\n              <td>\n              {#if displayToggles.delaunay == 0}\n              off\n              {/if}\n              {#if displayToggles.delaunay == 1}\n              {gisInfo.delaunay}\n              {/if}\n              </td>\n            {/if}\n          </tr>\n        </table>\n        {/if}\n      \n        {#if hexbinInfo.spaceId}\n          <table>\n              <tr>\n                <td style=\"color:blue;\" on:click='toggleDisplayOption(\"hexbins\")'>\n                  CLI hexbins: </td><td>\n                  {#if displayToggles.hexbins == 0}\n                  off\n                  {/if}\n                  {#if displayToggles.hexbins == 1}\n                  on\n                  {/if}\n                  {#if displayToggles.hexbins == 2}\n                  centroids\n                  {/if}\n                </td>\n              </tr><tr>\n                <td>{hexbinInfo.spaceId}, zoom {hexbinInfo.zoomLevels}</td>\n              </tr>\n          </table>\n        {/if}\n\n        <!-- Basemap selector -->\n        <div class=\"controls_left_selector\">basemap:\n          <select bind:value=\"basemap\" class=\"controls_left_dropdown\">\n            {#each Object.keys(basemaps) as basemap}\n              <option value=\"{basemap}\">{basemap}</option>\n            {/each}\n          </select>\n        </div>\n\n        {#if isProjectable(basemap) }\n          <!-- Projection selector -->\n          <div class=\"controls_left_selector\">projection:\n            <select bind:value=\"projection\" class=\"controls_left_dropdown\">\n              {#each Object.keys(projections) as projection}\n                <option value=\"{projection}\">{projection}</option>\n              {/each}\n            </select>\n          </div>\n        {/if}\n\n        <!-- Export scene -->\n          <button on:click=\"fire('exportScene')\" style=\"float: right;\">export</button>\n      {/if}\n    </div>\n\n    <!-- Demo mode context -->\n    {#if demoMode && displayToggles.label != null}\n      <!-- Selected label property and value info -->\n      <div style=\"margin: 5px 0px;\">\n        Features labeled by <b>{displayToggles.label}</b>\n      </div>\n    {/if}\n\n    {#if demoMode && featurePointSizeProp != null}\n      <!-- Selected point size property and value info -->\n      <div style=\"margin: 5px 0px;\">\n        Points scaled by <b>{featurePointSizeProp}</b>\n      </div>\n    {/if}\n\n    {#if demoMode && featureProp && featurePropCount != null}\n      <!-- Selected feature property and value info -->\n      <div style=\"margin: 5px 0px;\">\n        Analyzing property <b>{featureProp}</b> by <b>{displayToggles.vizMode}</b>\n      </div>\n\n      <!-- Histogram for demo mode -->\n      {#if displayToggles.vizMode === 'range'}\n        <div class=\"hideOnMobilePortrait\">\n          <FeaturePropHistogram\n            showHeader={false}\n            minFilter={featurePropMinFilter}\n            maxFilter={featurePropMaxFilter}\n            valueCounts={sortedFeaturePropValueCounts}\n            valueColorFunction={featurePropValueColorFunction}\n          />\n        </div>\n      {:elseif displayToggles.vizMode === 'rank' && featurePropValueCounts}\n        <!-- Top values list -->\n        <div class=\"hideOnMobilePortrait\">\n          <FeaturePropTopValues\n            showHeader={false}\n            prop={featureProp}\n            bind:propValue=\"featurePropValue\"\n            bind:valueSort=\"featurePropValueSort\"\n            valueCounts={sortedFeaturePropValueCounts}\n            valueColorFunction={featurePropValueColorFunction}\n          />\n        </div>\n      {:elseif displayToggles.vizMode === 'property'}\n        <!-- Top values list -->\n        <div class=\"hideOnMobilePortrait\">\n          <FeaturePropTopValues\n            showHeader={false}\n            prop={featureProp}\n            bind:propValue=\"featurePropValue\"\n            bind:valueSort=\"featurePropValueSort\"\n            valueCounts={sortedFeaturePropValueCounts}\n            valueColorFunction={featurePropValueColorFunction}\n          />\n        </div>\n      {/if}\n    {/if}\n  </div>\n\n  <div id=\"viz\" class=\"panel hideOnMobilePortrait\" class:hideInDemoMode=\"demoMode\">\n    <div>\n      <!-- Selected feature property stats -->\n      {#if featureProp && featurePropCount != null}\n        <div style=\"margin: 5px 0 5px 0;\" class=\"hideOnMobile\">\n          <div>{featurePropCount} unique values in the viewport</div>\n\n          {#if featurePropMin != null}\n            <div>min: {featurePropMin}, median: {featurePropMedian}, max: {featurePropMax}</div>\n            <div>\n              μ: {featurePropMean.toFixed(2)},\n              σ: {featurePropStdDev.toFixed(2)},\n              {featurePropSigma.toFixed(2)}% ({featurePropSigmaFloor.toFixed(2)} - {featurePropSigmaCeiling.toFixed(2)})\n            </div>\n          {/if}\n        </div>\n      {/if}\n\n      <!-- Color mode selector -->\n      {#if displayToggles}\n        <div>\n          Analyze by\n          <select bind:value=\"displayToggles.vizMode\" on:change=\"updateFeaturePropValueSort()\">\n            {#each Object.keys(vizModes) as mode}\n              {#if featureProp || !vizModeUsesProperty(mode)}\n                <option value=\"{mode}\">{vizModes[mode].label || mode}</option>\n              {/if}\n            {/each}\n          </select>\n        </div>\n      {/if}\n\n      {#if sortedUniqueFeaturePropsSeen.length > 0 && vizModeUsesProperty(displayToggles.vizMode)}\n        <!-- Visualize property selector -->\n        <div class=\"property_selector\">\n          <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Visualize by property</span>\n          <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featureProp\">\n            <option value=\"\"></option>\n            <!-- JSON.stringify is a hint to help Svelte uniquely identify the object values -->\n            <!-- see https://v2.svelte.dev/guide#keyed-each-blocks -->\n            {#each sortedUniqueFeaturePropsSeen as [prop] (JSON.stringify(prop))}\n              <option value=\"{prop}\">{prop}</option>\n            {/each}\n          </select>\n        </div>\n\n        <!-- Filter value selector -->\n        {#if featureProp && featurePropValueCounts}\n          <div class=\"property_selector\">\n            <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Filter by value</span>\n            <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featurePropValue\">\n              <option value=\"\"></option>\n              {#each featurePropValueCounts as [value, count]}\n                <option value=\"{value}\">({count}x) {value}</option>\n              {/each}\n            </select>\n          </div>\n        {/if}\n      {/if}\n\n\n      {#if featureProp && featurePropCount != null}\n        <!-- Pattern selector -->\n        {#if displayToggles}\n          <div class=\"property_selector\">\n            <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Pattern</span>\n            <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.pattern\">\n              {#each patternOptions as pattern}\n                <option value=\"{pattern}\">{pattern}</option>\n              {/each}\n            </select>\n          </div>\n\n          {#if displayToggles.pattern}\n            <div class=\"property_selector\">\n              <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Pattern color</span>\n              <input style=\"flex: 1 1 auto; width: 100%;\" type=\"color\" bind:value=\"displayToggles.patternColor\">\n            </div>\n          {/if}\n        {/if}\n\n        <!-- Color palette and range filters -->\n        {#if showFeaturePropPalette(displayToggles.vizMode)}\n          <div class=\"hideOnMobile\">\n            Color palette\n            <select bind:value=\"featurePropPaletteName\">\n              {#each Object.keys(colorPalettes) as palette}\n                <option value=\"{palette}\">{palette}</option>\n              {/each}\n            </select>\n\n            <label>\n              <input type=\"checkbox\" bind:checked=\"featurePropPaletteFlip\">\n              Flip\n            </label>\n          </div>\n\n          {#if featurePropMin != null}\n            {#if useFeaturePropRangeLimit(displayToggles.vizMode)}\n              <div>\n                Limit values:\n                <select bind:value=\"featurePropRangeFilter\" on:change=\"updateFeaturePropRangeFilter(this.value)\">\n                  <option value=\"0\">all</option>\n                  <option value=\"4\">sigma 4</option>\n                  <option value=\"3\">sigma 3</option>\n                  <option value=\"2\">sigma 2</option>\n                  <option value=\"1\">sigma 1</option>\n                  <option value=\"custom\" class=\"hideOnMobile\">custom</option>\n                </select>\n                <input class=\"range_filter hideOnMobile\" type=\"text\" bind:value=\"featurePropMinFilterInput\" placeholder=\"min\" on:input=\"updateFeaturePropRangeFilter('custom')\" on:keydown=\"event.stopPropagation()\">\n                <input class=\"range_filter hideOnMobile\" type=\"text\" bind:value=\"featurePropMaxFilterInput\" placeholder=\"max\" on:input=\"updateFeaturePropRangeFilter('custom')\" on:keydown=\"event.stopPropagation()\">\n              </div>\n\n              <label style=\"margin-bottom: 5px;\">\n                <input type=\"checkbox\" bind:checked=\"featurePropHideOutliers\">\n                Hide values outside range\n              </label>\n\n              {#if featurePropMostlyNumeric}\n                <FeaturePropHistogram\n                  minFilter={featurePropMinFilter}\n                  maxFilter={featurePropMaxFilter}\n                  valueCounts={sortedFeaturePropValueCounts}\n                  valueColorFunction={featurePropValueColorFunction}\n                />\n              {/if}\n            {/if}\n          {/if}\n        {/if}\n      {/if}\n    </div>\n\n    {#if sortedUniqueFeaturePropsSeen.length > 0}\n      <!-- Label property selector -->\n      <div class=\"property_selector\">\n        <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Label features by</span>\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.label\">\n          <option value=\"\"></option>\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\n            <option value=\"{prop}\">{prop}</option>\n          {/each}\n        </select>\n      </div>\n\n      <!-- Point size property selector -->\n      <div class=\"property_selector\">\n        <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Scale point size by</span>\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"featurePointSizeProp\">\n          <option value=\"\"></option>\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\n            <!-- {#if isPropNumeric(parsePropStack(prop), { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold })} -->\n              <option value=\"{prop}\">{prop}</option>\n            <!-- {/if} -->\n          {/each}\n        </select>\n      </div>\n\n      <!-- Point min/max pixel size -->\n      {#if featurePointSizeProp}\n        <div class=\"property_selector hideOnMobile\">\n          <span style=\"flex: 0 0 auto; margin-right: 5px; width: 115px;\">Point size (px):</span>\n          <input style=\"flex: 1 1 auto; width: 100%;\" class=\"range_filter\" type=\"text\" bind:value=\"featurePointSizeDisplayRange[0]\" placeholder=\"min\" on:keydown=\"event.stopPropagation()\">\n          <input style=\"flex: 1 1 auto; width: 100%;\" class=\"range_filter\" type=\"text\" bind:value=\"featurePointSizeDisplayRange[1]\" placeholder=\"max\" on:keydown=\"event.stopPropagation()\">\n        </div>\n      {/if}\n    {/if}\n\n    {#if !(featureProp && featurePropCount != null)}\n      Select a feature property to analyze, from the property list or by clicking on an individual feature.\n    {/if}\n    \n    <!-- clustering property selector -->\n    {#if sortedUniqueFeaturePropsSeen.length > 0 && displayToggles.clustering > 0}\n      <div style=\"display: flex; flex-direction: row; align-items: center; margin: 5px 0px;\">\n        <span style=\"flex: 0 0 auto; margin-right: 5px;\">Cluster features by</span>\n        <select style=\"flex: 1 1 auto; width: 100%;\" bind:value=\"displayToggles.clusteringProp\">\n          <option value=\"\"></option>\n          {#each sortedUniqueFeaturePropsSeen as [prop]}\n            <option value=\"{prop}\">{prop}</option>\n          {/each}\n        </select>\n      </div>\n    {/if}\n\n    <!-- Top values list -->\n    {#if featureProp && featurePropValueCounts}\n      <div class=\"hideOnMobile\">\n        <FeaturePropTopValues\n          prop={featureProp}\n          bind:propValue=\"featurePropValue\"\n          bind:valueSort=\"featurePropValueSort\"\n          valueCounts={sortedFeaturePropValueCounts}\n          valueColorFunction={featurePropValueColorFunction}\n        />\n      </div>\n    {/if}\n  </div>\n</div>\n\n<div id=\"controls_right\" class=\"column hideOnMobile\" class:hideInDemoMode=\"demoMode\">\n  <div id=\"tag_summary\" class=\"panel\">\n    <table id=\"tag_stats\">\n      {#if featuresInViewport.length}\n        <tr><td>features in viewport</td><td>{featuresInViewport.length}</td></tr>\n      {/if}\n      {#if numFeatureTagsInViewport != null}\n        <tr><td>feature tags in viewport</td><td>{numFeatureTagsInViewport}</td></tr>\n      {/if}\n      <tr><td>unique tags in viewport</td><td>{uniqueTagsInViewport.size}</td></tr>\n      <tr><td>unique tags seen</td><td>{uniqueTagsSeen.size}</td></tr>\n    </table>\n    <div id=\"tags_filtered\">\n      filtering by tags:<br>\n      {#if tagFilterList.length > 0}\n        {tagFilterList.join(', ')}<br><br>\n      {:else}\n        <i>no tags filtered<br><br></i>\n      {/if}\n    </div>\n    <div style=\"color:blue;\" id=\"clear_filters\" on:click=\"set({ tagFilterList: [] })\">CLEAR TAG FILTERS</div>\n    <div id=\"and_or\">\n      <input type=\"radio\" g=\"and_or\" value=\"or\" bind:group='tagFilterAndOr'>or\n      <input type=\"radio\" name=\"and_or\" value=\"and\" bind:group='tagFilterAndOr'>and<br>\n    </div>\n  </div>\n  <div id=\"tag_panel\" class=\"panel\">\n    <span style=\"color:blue;\" on:click=\"toggleTagFilterViewport()\">\n      {#if tagFilterViewport}\n        [show all tags seen]\n      {:else}\n        [only show tags in view]\n      {/if}\n    </span>\n    <span style=\"color:blue;\" on:click=\"toggleTagFilterAt()\">\n      {#if tagFilterAt}\n        [show all tag names]\n      {:else}\n        [only show @ tags]\n      {/if}\n    </span>\n    <span style=\"color:blue;\" on:click=\"toggleTagSort()\">\n      [sort by {nextTagSort}]\n    </span>\n    <div id=\"tags\">\n      <div>\n        <input id=\"tag_search\" type=\"text\" bind:value=\"tagFilterSearch\" placeholder=\"Filter tags\" on:keydown=\"event.stopPropagation()\">\n      </div>\n\n      <!-- The JSON.stringify gives Svelte a way to uniquely identify the full tag info.\n        This ensures that the correct checkboxes stay checked when the list is re-ordered\n        (for instance when tag counts change). See https://svelte.technology/guide#keyed-each-blocks.\n      -->\n      {#each tagDisplayList.slice(0, 500) as tag (JSON.stringify(tag))}\n        <label>\n          <input type=\"checkbox\" value=\"{tag[0]}\" bind:group='tagFilterList'>\n          ({tag[1]}x) {tag[0]}\n        </label>\n        <br>\n      {/each}\n\n      {#if tagDisplayList.length > 500}\n        <i>Displaying the top 500 tags of {tagDisplayList.length} total</i>\n      {/if}\n    </div>\n  </div>\n\n  <!-- property search UI-->\n  {#if spaceInfo && spaceInfo.properties}\n    <div id=\"properties\" class=\"panel hideOnMobile\">\n      <PropertySearchList\n        properties={spaceInfo.properties}\n        bind:propertySearch=\"propertySearch\"\n      />\n    </div>\n  {/if}\n</div>\n\n<!-- feature popup content, hidden in the main UI and synced to the Leaflet popup -->\n<div style=\"display: none\">\n  <div id=\"popupContent\" style=\"margin-top: 18px;\">\n    <FeaturePopup\n      feature={feature}\n      featureProp={featureProp}\n      featurePinned={featurePinned}\n      featurePropValue={featurePropValue}\n      on:selectProp=\"setFeatureProp({\n        featureProp: (event.prop !== featureProp ? event.prop : null),\n        featurePropValue: ''\n      })\"\n      on:selectValue=\"setFeatureProp({\n        featureProp: event.prop,\n        featurePropValue: (event.value !== featurePropValue ? event.value : '')\n      })\"\n    />\n  </div>\n</div>\n\n<script>\n\nimport { basemaps, getBasemapScene, getBasemapName, getDefaultBasemapName, getNextBasemap,\n          projections, getProjectionScene, getDefaultProjectionName, isProjectable, } from './basemaps';\nimport { colorPalettes } from './colorPalettes';\nimport { vizModes, vizHelpers } from './vizModes';\nimport { displayOptions, defaultDisplayOptionValue } from './displayOptions';\nimport { calcFeaturePropertyStats } from './stats';\nimport { parseNestedObject, parsePropStack, formatPropStack, parseNumber, mostlyNumeric, lookupProperty, PROP_TYPES } from './utils';\n\nexport default {\n  data() {\n    return {\n      // set these to empty strings (not null) to get placeholder text in input\n      spaceId: '',\n      hubApi: 'http://localhost:8080/hub',\n      token: '',\n      spaceInfo: null,\n      hexbinInfo: {},\n      gisInfo: {},\n      demoMode: false, // display collapsed UI demo mode\n      feature: null,\n      featureProp: null,\n      featurePropValue: '',\n      featurePropCount: null,\n      featurePropValueCounts: null,\n      featurePropValueSort: 'count',\n      featurePropNumericThreshold: 80, // minimum % of values that must be numeric to support range, etc.\n      featurePropCheckNumeric: null, // the property name that was active when we last checked for numeric-ness\n      featurePropPaletteName: 'viridis', // TODO: move palette to import\n      featurePropPaletteFlip: false,\n      featurePropMin: null,\n      featurePropMax: null,\n      featurePropMinFilterInput: '', // use empty string to get input placeholder\n      featurePropMaxFilterInput: '', // use empty string to get input placeholder\n      featurePropMean: null,\n      featurePropMedian: null,\n      featurePropStdDev: null,\n      featurePropSigma: null,\n      featurePropSigmaFloor: null,\n      featurePropSigmaCeiling: null,\n      featurePointSizeDisplayRange: [4, 20],\n      featurePointSizeProp: '', // setting this to null breaks the point toggle\n      \n      // these are params\n//       clustering: null,\n//       quadCountmode: null,\n//       quadRez: 4,\n//       voronoi: 'off',\n      \n\n      tagsWithCountsInViewport: [],\n      tagFilterList: [],\n      tagFilterAndOr: 'or',\n      tagFilterViewport: false,\n      tagFilterAt: false,\n      tagSort: 'count',\n      tagFilterSearch: '', // set these to empty strings (not null) to get placeholder text in input\n      propertySearch: {},\n      propertySearchOverride: null,\n\n      featuresInViewport: [],\n      featurePropTypesCache: {}, // cache of inferred feature property types\n      uniqueTagsSeen: new Set(),\n\n      uniqueFeaturePropsSeen: new Map(),\n\n      displayToggles: null,\n      vizModes, // need to reference here to make accessible to templates and tangram functions\n      colorPalettes, // need to reference here to make accessible to templates and tangram functions\n      vizHelpers, // need to reference here to make accessible to templates and tangram functions\n      basemaps, // need to reference here to make accessible to templates\n      projections, // need to reference here to make accessible to templates\n      isProjectable, // needa to reference here to make accessible to templates\n    }\n  },\n\n  components: {\n    FeaturePropHistogram: './FeaturePropHistogram.svelte',\n    FeaturePropTopValues: './FeaturePropTopValues.svelte',\n    FeaturePopup: './FeaturePopup.svelte',\n    PropertySearchList: './PropertySearchList.svelte'\n  },\n\n  computed: {\n    basemapScene: ({ basemap, projection }) => {\n      if (!isProjectable(basemap)) {\n        projection = getDefaultProjectionName();\n      }\n      const scene = getBasemapScene(basemap, projection);\n      if (scene) {\n        scene.global = {\n          ...scene.global,\n          vizModes\n        };\n      }\n      return scene;\n    },\n\n    // apply range filters if needed\n    featurePropMinFilter: ({ displayToggles, featurePropMin, featurePropMinFilterInput }) => {\n      // only use if color mode supports range filter\n      if (displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\n        const val = parseNumber(featurePropMinFilterInput);\n        if (typeof val === 'number' && !isNaN(val)) {\n          return val;\n        }\n      }\n      return featurePropMin;\n    },\n\n    featurePropMaxFilter: ({ displayToggles, featurePropMax, featurePropMaxFilterInput }) => {\n      // only use if color mode supports range filter\n      if (displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\n        const val = parseNumber(featurePropMaxFilterInput);\n        if (typeof val === 'number' && !isNaN(val)) {\n          return val;\n        }\n      }\n      return featurePropMax;\n    },\n\n    featurePropRows: ({ feature }) => feature && parseNestedObject(feature.properties),\n\n    featurePropPalette: ({ featurePropPaletteName }) => {\n      return colorPalettes[featurePropPaletteName];\n    },\n\n    // update stats for current features and point size property (if one selected)\n    featurePointSizePropStats: ({ featuresInViewport, featurePointSizeProp }) => {\n      return calcFeaturePropertyStats(featuresInViewport, featurePointSizeProp);\n    },\n\n    // how point sizes are mapped to feature property values\n    featurePointSizeRange: ({ featurePointSizePropStats, featurePointSizeDisplayRange }) => {\n      return [\n        // value range for features in viewport\n        featurePointSizePropStats.min, featurePointSizePropStats.max,\n        // pixel size range to map these to\n        parseFloat(featurePointSizeDisplayRange[0]) || 5, parseFloat(featurePointSizeDisplayRange[1]) || 20\n      ];\n    },\n\n    sortedFeaturePropValueCounts: ({ featurePropValueCounts, featurePropValueSort }) => {\n      if (!featurePropValueCounts) {\n        return [];\n      }\n\n      if (featurePropValueSort === 'values') {\n        // copy and re-sort on value (descending) if needed\n        return Array.from(featurePropValueCounts).sort((a, b) => {\n          // try to get a number\n          let an = parseNumber(a[0]);\n          let bn = parseNumber(b[0]);\n\n          // sort nulls and NaNs to the bottom\n          an = (an == null || isNaN(an)) ? -Infinity : an;\n          bn = (bn == null || isNaN(bn)) ? -Infinity : bn;\n\n          return bn - an; // descending sort\n        });\n      }\n      return featurePropValueCounts; // return original/unmodified values\n    },\n\n    // function to calculate color for a feature prop value, based on current selection state\n    featurePropValueColorFunction: ({\n      displayToggles,\n      featurePropMinFilter, featurePropMaxFilter,\n      featurePropPalette, featurePropPaletteFlip, featurePropValueCounts, vizHelpers }) => {\n\n      return (value) => {\n        const vizMode = displayToggles.vizMode;\n        if (vizModes[vizMode] && vizModes[vizMode].color) {\n          return vizModes[vizMode].color(\n            value, {\n              displayToggles,\n              featurePropMinFilter, featurePropMaxFilter,\n              featurePropPalette, featurePropPaletteFlip, featurePropValueCounts,\n              vizHelpers\n            }\n          );\n        }\n        return 'rgba(127, 127, 127, .25)'; // color for null values?\n\n      };\n    },\n\n    featurePropMostlyNumeric: ({ featureProp, featurePropTypesCache, featuresInViewport, featurePropNumericThreshold }) => {\n      return isPropNumeric(featureProp, { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold });\n    },\n\n    featurePropValueCountHash: ({ featurePropValueCounts }) => featurePropValueCounts && hashString(JSON.stringify(featurePropValueCounts)),\n\n    nextTagSort: ({ tagSort }) => (tagSort === 'count' ? 'name' : 'count'),\n\n    tagsWithCountsInViewport: ({ featuresInViewport }) => {\n      // grab the tags from Tangram's viewport tiles\n      let tagsViewport = [];\n      featuresInViewport.forEach(x => {\n        if (x.properties['@ns:com:here:xyz'] && x.properties['@ns:com:here:xyz'].tags) {\n          tagsViewport.push(...x.properties['@ns:com:here:xyz'].tags);\n        }\n      })\n\n      const tagsWithCountsInViewport =\n        Object.entries(\n          featuresInViewport\n            .filter(f => f.properties['@ns:com:here:xyz'] && f.properties['@ns:com:here:xyz'].tags)\n            .flatMap(f => f.properties['@ns:com:here:xyz'].tags)\n            .reduce((tagCounts, tag) => {\n                tagCounts[tag] = tagCounts[tag] ? tagCounts[tag] + 1 : 1;\n                return tagCounts;\n              }, {}))\n        .sort((a, b) => b[1] > a[1] ? 1 : (b[1] > a[1] ? -1 : 0));\n      return tagsWithCountsInViewport;\n    },\n\n    uniqueTagsInViewport: ({ tagsWithCountsInViewport }) => new Set(tagsWithCountsInViewport.map(v => v[0])),\n\n    sortedUniqueFeaturePropsSeen: ({ uniqueFeaturePropsSeen }) => {\n      // alphabetical sort, but with @ properties at bottom\n      return Array.from(uniqueFeaturePropsSeen.keys())\n        .sort((a, b) => a[0] === '@' ? 1 : b[0] === '@' ? -1 : a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0)\n        .map(prop => [prop, uniqueFeaturePropsSeen.get(prop)]);\n    },\n\n    numFeatureTagsInViewport: ({ tagsWithCountsInViewport }) => tagsWithCountsInViewport.reduce((acc, cur) => acc + cur[1], 0),\n\n    // build the list of tags for display with checkboxes\n    tagDisplayList: ({ tagsWithCountsInViewport, tagSort, tagFilterList, tagFilterViewport, tagFilterAt, tagFilterSearch, uniqueTagsSeen }) => {\n      const tagCountMap = new Map();\n\n      // optional filters\n      // e.g. remove tags without an @ if desired, or text search\n      const tagFilterFunc = tag => {\n        const at = tagFilterAt ? tag.includes('@') : true;\n        const search = (tagFilterSearch && tagFilterSearch.length >= 3) ? tag.includes(tagFilterSearch) : true;\n        return (at && search) || tagFilterList.indexOf(tag) > -1; // always include selected tags\n      };\n\n      // add any tags that are selected, but not currently in the viewport\n      // this also handles cases where an impossible tag combo is selected (postcode 98125 AND postcode 98122),\n      // but we want those tags to still show up in the list so they can be de-selected\n      // note this ignores filters to ensure these tags can always be seen/de-selected\n      tagFilterList.forEach(tag => tagCountMap.set(tag, 0));\n\n      // add all uniquely seen tags that aren't currently in the viewport\n      if (!tagFilterViewport) {\n        uniqueTagsSeen\n          .forEach(tag => {\n            if (tagFilterFunc(tag)) {\n              tagCountMap.set(tag, 0);\n            }\n          });\n      }\n\n      // add tags currently in the viewport\n      tagsWithCountsInViewport\n        .filter(([tag]) => tagFilterFunc(tag))\n        .forEach(([tag, count]) => tagCountMap.set(tag, count));\n\n      // convert to array entries for sorting\n      let tagCounts = [...tagCountMap.entries()];\n\n      // sort tags as desired\n      if (tagSort === 'name') {\n        tagCounts.sort((a, b) => {\n          if (a[0] === b[0]) {\n            return a[1] < b[1] ? 1 : -1;\n          }\n          return a[0] < b[0] ? 1 : (a[0] > b[0] ? -1 : 0);\n        });\n      }\n      else if (tagSort === 'count') {\n        tagCounts.sort((a, b) => {\n          if (a[1] === b[1]) {\n            return a[0] < b[0] ? 1 : (a[0] > b[0] ? -1 : 0);\n          }\n          return a[1] < b[1] ? 1 : -1;\n        });\n      }\n\n      return tagCounts;\n    },\n\n    // format selected tags as a query parameter for XYZ tile requests\n    tagFilterQueryParam: ({ tagFilterList, tagFilterAndOr }) => {\n      if (tagFilterList.length === 0) {\n        return null;\n      }\n\n      if (tagFilterAndOr === 'and') {\n        return tagFilterList.join('+');\n      }\n      else {\n        return tagFilterList.join(',');\n      }\n    },\n\n    // format property searches as query parameters for XYZ tile requests\n    propertySearchQueryParams: ({ propertySearch }) => {\n      return Object.entries(propertySearch)\n        .reduce((params, [prop, { op, equals, min, max }]) => {\n          const p = `p.${prop}`;\n          if (op === 'equals' && equals) {\n            params.push([p, equals]);\n          }\n          else if (op === 'range') {\n            min = parseFloat(min);\n            max = parseFloat(max);\n\n            if (typeof min === 'number' && !isNaN(min)) {\n              params.push([p, `gt=${min}`]);\n            }\n\n            if (typeof max === 'number' && !isNaN(max)) {\n              params.push([p, `lt=${max}`]);\n            }\n          }\n          return params;\n        }, []);\n    },\n\n    queryParams: ({\n        spaceId, token, basemap, projection,\n        demoMode,\n        displayToggles,\n        featureProp,\n        featurePropValue,\n        featurePropPaletteName, featurePropPaletteFlip,\n        featurePropRangeFilter,\n        featurePropMinFilterInput,\n        featurePropMaxFilterInput,\n        featurePropValueSort,\n        featurePropHideOutliers,\n        featurePointSizeProp,\n        featurePointSizeDisplayRange,\n        tagFilterQueryParam,\n        propertySearch\n      }) => {\n\n      const params = new URLSearchParams();\n\n      if (spaceId) {\n        params.set('space', spaceId);\n      }\n\n      if (token) {\n        params.set('token', token);\n      }\n\n      params.set('basemap', basemap);\n\n      params.set('projection', projection);\n\n      params.set('demo', demoMode ? 1 : 0);\n\n      for(const p in displayToggles) {\n        if (displayToggles[p] != null) {\n          params.set(p, displayToggles[p]);\n        }\n      }\n\n      if (tagFilterQueryParam) {\n        params.set('tags', tagFilterQueryParam);\n      }\n\n      if (featureProp) {\n        params.set('property', featureProp);\n      }\n\n      if (featurePropValue) {\n        params.set('value', featurePropValue);\n      }\n\n      params.set('palette', featurePropPaletteName);\n      params.set('paletteFlip', featurePropPaletteFlip);\n\n      // save range filter (if current color mode supports it)\n      if (featurePropRangeFilter && displayToggles && useFeaturePropRangeLimit(displayToggles.vizMode)) {\n        params.set('rangeFilter', featurePropRangeFilter);\n        if (featurePropRangeFilter === 'custom') {\n          params.set('rangeFilterMin', featurePropMinFilterInput);\n          params.set('rangeFilterMax', featurePropMaxFilterInput);\n        }\n      }\n\n      params.set('sort', featurePropValueSort);\n      params.set('hideOutliers', featurePropHideOutliers);\n\n      params.set('pointSizeProp', featurePointSizeProp);\n      params.set('pointSizeRange', JSON.stringify(featurePointSizeDisplayRange));\n\n      params.set('propertySearch', JSON.stringify(propertySearch));\n\n      return params;\n    }\n\n  },\n\n  onstate({ changed, current, previous }) {\n    // update globally seen tags\n    if (changed.uniqueTagsInViewport) {\n      this.set({\n        uniqueTagsSeen: new Set([...current.uniqueTagsSeen, ...current.uniqueTagsInViewport].filter(x => x))\n      });\n    }\n\n    // check if globally seen properties need to be updated\n    const uniqueFeaturePropsSeen = new Map(current.uniqueFeaturePropsSeen); // get currently known props\n    let updateUniqueFeaturePropsSeen = false;\n\n    // seed globally seen properties from space stats\n    if (changed.spaceInfo && current.spaceInfo) {\n\n      Object.entries(current.spaceInfo.properties)\n        .forEach(([prop, value]) => {\n          const propStack = prop.split(':'); // XYZ API uses ':' delimiter\n          prop = formatPropStack(propStack);\n          uniqueFeaturePropsSeen.set(prop, {\n            ...value,\n            propStack\n          });\n        });\n      updateUniqueFeaturePropsSeen = true;\n    }\n\n    // update globally seen properties from current feature set\n    if (changed.featuresInViewport) {\n      current.featuresInViewport.forEach(feature => {\n        parseNestedObject(feature.properties)\n          .filter(p => !p.prop.startsWith('$')) // don't include special tangram context properties\n          .filter(p => !uniqueFeaturePropsSeen.has(p.prop)) // skip properties we already know about\n          .forEach(p => {\n            uniqueFeaturePropsSeen.set(p.prop, { propStack: p.propStack }); // add new props\n          });\n      });\n      updateUniqueFeaturePropsSeen = true;\n\n      // reset property type cache (re-evaluatate property types when new features are available)\n      this.set({ featurePropTypesCache: {} });\n    }\n\n    // update feature props if needed\n    if (updateUniqueFeaturePropsSeen) {\n      this.set({ uniqueFeaturePropsSeen });\n    }\n\n    // Apply Tangram scene updates based on state change\n    if (current.spaceInfo &&\n        (changed.basemapScene || changed.spaceInfo || changed.projection)) {\n      this.fire('loadScene', current);\n    }\n\n    if (changed.displayToggles ||\n        changed.tagFilterQueryParam ||\n        changed.propertySearchQueryParams ||\n        changed.hexbinInfo ||\n        changed.gisInfo ||\n        changed.featureProp ||\n        changed.featurePropValue ||\n        changed.featurePointSizeProp ||\n        changed.featurePointSizeDisplayRange ||\n        changed.featurePropPalette ||\n        changed.featurePropPaletteFlip ||\n        changed.featurePropValueCountHash ||\n        changed.featurePropMinFilter ||\n        changed.featurePropMaxFilter ||\n        changed.featurePropHideOutliers) {\n      this.fire('updateScene', current);\n    }\n\n    // mark space as loaded\n    // used to hide UI during load (maybe replace with promise)\n    if (changed.spaceInfo && current.spaceInfo) {\n      this.set({\n        spaceLoading: false\n      });\n    }\n\n    // update query string as needed\n    if (changed.queryParams) {\n      this.fire('updateQueryString', current);\n    }\n  },\n\n  onupdate({ changed, current, previous }) {\n    // note: svelte needs these checks in onupdate instead of onstate because of interdependencies when\n    // calling a set() from inside onstate that triggers another set(); these issues are reportedly fixed in v3,\n    // separating this check out into onupdate for now\n\n    // reset range filter to 'all' when selected property changes\n    if (changed.featureProp && previous && previous.featureProp && current.featurePropRangeFilter === 'custom') {\n      this.updateFeaturePropRangeFilter(0); // zero = use all values / no range limiting\n    }\n    // update range filter when underlying data changes\n    else if (changed.featurePropMin || changed.featurePropMax) {\n      this.updateFeaturePropRangeFilter();\n    }\n\n    // additional checks when feature property values update\n    if (changed.featurePropValueCountHash &&\n        current.displayToggles != null &&\n        current.featurePropCheckNumeric !== current.featureProp) {\n\n        // if color 'range' mode is active, check if values are sufficiently numeric, and if so,\n        // automatically switch to 'rank' mode instead (no use using range controls for non-numeric data)\n        let vizMode = current.displayToggles.vizMode;\n        if (!current.featurePropMostlyNumeric && vizMode === 'range') {\n          vizMode = 'rank';\n        }\n        // or the converse\n        else if (current.featurePropMostlyNumeric && vizMode === 'rank') {\n          vizMode = 'range';\n        }\n\n        this.set({\n          featurePropCheckNumeric: current.featureProp, // record that we last ran the check for this property name\n          displayToggles: { ...current.displayToggles, vizMode }\n        });\n        this.updateFeaturePropValueSort();\n    }\n\n    // tell map to update popup content when it changes\n    // (this is in svelte onupdate because it fires after the DOM has been updated with new content)\n    if (changed.feature ||\n        changed.featureProp ||\n        changed.featureProp ||\n        changed.featurePinned) {\n      if (current.feature) {\n        this.fire('updatePopup');\n      }\n    }\n  },\n\n  methods: {\n    setFromQueryParams(params) {\n      // convert query params to object\n      params = [...params.entries()].reduce((p, [k, v]) => { p[k] = v; return p; }, {});\n\n      // set these to empty strings (not null) to get placeholder text in input\n      const spaceId = params.space || '';\n      const token = '';\n      const demoMode = (parseInt(params.demo) === 1);\n\n      // parse out display option toggles\n      const displayToggles = {};\n      params.vizMode = params.vizMode || params.colors; // backwards compatibility for `colors` parameter\n      for (const p in params) {\n        if (displayOptions[p]) {\n          if (displayOptions[p].parse) {\n            // parse display options values (e.g. convert strings to numbers, etc.)\n            displayToggles[p] = displayOptions[p].parse(params[p]);\n          }\n          else if (params[p] !== 'null' && params[p] !== 'undefined') {\n            displayToggles[p] = params[p];\n          }\n        }\n      }\n\n      // set default values for display options\n      for (const p in displayOptions) {\n        if (displayToggles[p] == null) {\n          displayToggles[p] = defaultDisplayOptionValue(p);\n        }\n      }\n\n      // parse tags\n      let tagFilterList = [];\n      let tagFilterAndOr = this.get().tagFilterAndOr;\n      if (params.tags) {\n        // look for OR tags\n        if (params.tags.includes(',')) {\n          tagFilterList = params.tags.split(',');\n          tagFilterAndOr = 'or';\n        }\n        // look for AND tags\n        // if (params.tags.includes('+')) {\n        else {\n          tagFilterList = params.tags.split('+');\n          tagFilterAndOr = 'and';\n        }\n      }\n\n      let basemap = getBasemapName(params.basemap);\n      if (!getBasemapScene(basemap) || !params.basemap) { // check for no parameter\n        basemap = getDefaultBasemapName();\n      }\n      let projectable = isProjectable(basemap);\n\n      let projection = params.projection;\n      if (!getProjectionScene(projection) || !projectable) {\n        projection = getDefaultProjectionName();\n      }\n\n      // parse selected feature property\n      const featureProp = params.property;\n\n      // parse selected property value\n      let featurePropValue = params.value === undefined ? '' : params.value;\n      if (featurePropValue && featurePropValue.match(/^\\d+$/)) {\n        featurePropValue = parseNumber(featurePropValue); // parse from string if needed\n      }\n\n      // parse color palette\n      const featurePropPaletteFlip = (params.paletteFlip === 'true');\n      let featurePropPaletteName = this.get().featurePropPaletteName;\n      if (colorPalettes[params.palette]) {\n        featurePropPaletteName = params.palette;\n      }\n\n      // parse min/max range filter\n      const featurePropRangeFilter = params.rangeFilter;\n      let { featurePropMinFilterInput, featurePropMaxFilterInput } = this.get();\n      if (featurePropRangeFilter === 'custom') {\n        featurePropMinFilterInput = params.rangeFilterMin;\n        featurePropMaxFilterInput = params.rangeFilterMax;\n      }\n\n      const featurePropValueSort = params.sort || 'count';\n      const featurePropHideOutliers = (params.hideOutliers === 'true');\n\n      const featurePointSizeProp = params.pointSizeProp || '';\n      let featurePointSizeDisplayRange = this.get().featurePointSizeDisplayRange;\n      try { // protect against JSON.parse failure (it's brittle with string input)\n        featurePointSizeDisplayRange = JSON.parse(params.pointSizeRange);\n      } catch(e) {}\n\n      let propertySearch = {};\n      try { // protect against JSON.parse failure (it's brittle with string input)\n        propertySearch = JSON.parse(params.propertySearch);\n      } catch(e) {}\n\n      // set all params\n      this.set({\n        spaceId,\n        token,\n        basemap,\n        projection,\n        demoMode,\n        displayToggles,\n        featureProp,\n        featurePropValue,\n        featurePropPaletteName,\n        featurePropPaletteFlip,\n        featurePropRangeFilter,\n        featurePropMinFilterInput,\n        featurePropMaxFilterInput,\n        featurePropValueSort,\n        featurePropHideOutliers,\n        featurePointSizeProp,\n        featurePointSizeDisplayRange,\n        tagFilterList,\n        tagFilterAndOr,\n        propertySearch\n      });\n\n      this.updateSpace(false);\n      this.updateFeaturePropRangeFilter();\n      if (featurePropValueSort == null) {\n        this.updateFeaturePropValueSort();\n      }\n    },\n\n    updateSpace(loadScene) {\n      const { spaceId, token, basemapScene } = this.get();\n\n      if (spaceId ) {\n        this.set({\n          spaceLoading: true, // used to hide UI during load (maybe replace with promise)\n          uniqueTagsSeen: new Set() // reset unique tags when loading new space\n        });\n\n        this.fire('loadSpace', {\n          spaceId,\n          token\n        });\n\n        if (loadScene) {\n          this.fire('loadScene', {\n            basemapScene\n          });\n        }\n      }\n    },\n\n    setFeatureProp({ featureProp, featurePropValue }) {\n      // if selecting a feature property and current color mode isn't property-specific,\n      // automatically change to the 'property' color mode\n      const displayToggles = this.get().displayToggles;\n      let vizMode = displayToggles.vizMode;\n      if (vizModes[vizMode] && !vizModes[vizMode].useProperty) {\n        vizMode = 'property';\n      }\n\n      this.set({\n        featureProp,\n        featurePropValue,\n        displayToggles: { ...displayToggles, vizMode }\n      });\n    },\n\n    updateFeaturePropValueSort() {\n      // set default sort type (if there is one) for feature property color mode\n      const displayToggles = this.get().displayToggles;\n      let vizMode = displayToggles.vizMode;\n      if (vizModes[vizMode] && vizModes[vizMode].defaultSort) {\n        this.set({ featurePropValueSort: vizModes[vizMode].defaultSort });\n      }\n    },\n\n    updateFeaturePropRangeFilter(filter = null) {\n      const {\n        featurePropRangeFilter,\n        featurePropMin,\n        featurePropMax,\n        featurePropMean,\n        featurePropStdDev\n      } = this.get();\n\n      // update filter type if one specified, or keep existing\n      if (filter == null) {\n        filter = featurePropRangeFilter; // use existing filter\n      }\n      else {\n        this.set({\n          featurePropRangeFilter: filter.toString() // set new filter\n        });\n      }\n\n      // derive min/max values if needed (values specified manually in custom mode)\n      if (filter !== 'custom') {\n        const sigmaFilter = parseInt(filter);\n\n        if (typeof sigmaFilter === 'number' && sigmaFilter > 0 &&\n            featurePropMin != null && featurePropMax != null) { // require a min/max to be set\n          const min = Math.max(featurePropMin, parseFloat((featurePropMean - (featurePropStdDev * sigmaFilter)).toFixed(2)));\n          const max = Math.min(featurePropMax, parseFloat((featurePropMean + (featurePropStdDev * sigmaFilter)).toFixed(2)));\n\n          this.set({\n            featurePropMinFilterInput: min, featurePropMaxFilterInput: max\n          });\n        }\n        else { // no filter / \"all\"\n          this.set({\n            featurePropMinFilterInput: featurePropMin, featurePropMaxFilterInput: featurePropMax\n          });\n        }\n      }\n    },\n\n    toggleDisplayOption(prop) {\n      const displayToggles = this.get().displayToggles;\n\n      const vals = displayOptions[prop] && displayOptions[prop].values;\n      if (vals) {\n        const i = vals.indexOf(displayToggles[prop]);\n        if (i > -1) {\n          displayToggles[prop] = vals[(i + 1) % vals.length];\n        }\n        else {\n          displayToggles[prop] = vals[0];\n        }\n      }\n\n      this.set({ displayToggles });\n    },\n\n    toggleTagSort() {\n      this.set({ tagSort: this.get().nextTagSort });\n    },\n\n    toggleTagFilterViewport() {\n      this.set({ tagFilterViewport: !this.get().tagFilterViewport })\n    },\n\n    toggleTagFilterAt() {\n      this.set({ tagFilterAt: !this.get().tagFilterAt })\n    },\n\n    handleKeyPress({ key }) {\n      // b = toggle buildings\n      // l = line width\n      // n = names on map\n      // o = toggle polygon outlines\n      // p = make dots bigger\n      // r = toggle roads\n      // s = make dots smaller and lines narrower\n      // w = put polygons under water\n\n      if (key == \"m\") { // toggle basemap\n        this.set({ basemap: getNextBasemap(this.get().basemap) });\n      }\n      else {\n        if (key == \"b\") { // toggle buildings\n          this.toggleDisplayOption('buildings');\n        }\n        else if (key == \"l\") { // make lines smaller\n          this.toggleDisplayOption('lines');\n        }\n        else if (key == \"n\") { // hide places\n          this.toggleDisplayOption('places');\n        }\n        else if (key == \"o\") { // toggle outlines\n          this.toggleDisplayOption('outlines');\n        }\n        else if (key == \"p\") { // change point size\n          this.toggleDisplayOption('points');\n        }\n        else if (key == \"v\") { // toggle roads -- v for via! (changed from r because of cmd-r reload)\n          this.toggleDisplayOption('roads');\n        }\n        else if (key == \"w\") { // put polygons under water\n          this.toggleDisplayOption('water');\n        }\n        else if (key == \"x\") { // toggle hexbins, centroids, (and raw data?)\n          this.toggleDisplayOption('hexbins');\n        }\n        else if (key == \"k\") { // toggle server-side clustering\n          this.toggleDisplayOption('clustering');\n        }        \n      }\n    }\n\n  },\n\n  helpers: {\n    vizModeUsesProperty(mode) {\n      return vizModes[mode] && vizModes[mode].useProperty;\n    },\n\n    showFeaturePropPalette(mode) {\n      return vizModes[mode] && vizModes[mode].usePalette;\n    },\n\n    patternOptions: displayOptions.pattern.values, // for easier template access\n\n    // references here make these available to as template helper\n    useFeaturePropRangeLimit,\n    // isPropNumeric\n  }\n}\n\n// calculate whether a property is numeric based on the current features in the viewport, and cache the result\nfunction isPropNumeric(prop, { featurePropTypesCache, featuresInViewport, featurePropNumericThreshold }) {\n  const propStack = parsePropStack(prop);\n  if (featurePropTypesCache[prop] == null) {\n    // use a set to get unique values from array\n    const propValues = new Set(featuresInViewport\n      .map(f => lookupProperty(f.properties, propStack))\n      .filter(f => typeof f !== 'object')\n    );\n    featurePropTypesCache[prop] =\n      mostlyNumeric([...propValues], featurePropNumericThreshold) ? PROP_TYPES.NUMERIC : PROP_TYPES.STRING;\n  }\n  return featurePropTypesCache[prop] === PROP_TYPES.NUMERIC;\n}\n\nfunction useFeaturePropRangeLimit(vizMode) {\n  return vizModes[vizMode] && vizModes[vizMode].limitRange;\n}\n\nfunction formatFeaturePropValueColor(state, value) {\n  const vizMode = state.displayToggles.vizMode;\n  if (vizModes[vizMode] && vizModes[vizMode].color) {\n    return vizModes[vizMode].color(value, state);\n  }\n  return 'rgba(127, 127, 127, .25)';\n}\n\nfunction hashString (string) {\n    var hash = 0, i, chr, len;\n\n    if (string.length === 0) {\n        return hash;\n    }\n\n    for (i = 0, len = string.length; i < len; i++) {\n        chr   = string.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + chr;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n\n</script>\n\n<style>\n\n  .column {\n    position: absolute;\n    z-index: 1000;\n    min-height: 100vh;\n    max-height: 100vh;\n    display: flex;\n    flex-direction: column;\n    width: 300px;\n  }\n\n  .panel {\n    margin: 5px;\n    padding: 5px;\n    background-color: rgba(200, 200, 200, 0.75);\n    border: 1px solid black;\n    border-radius: 3px;\n    color: black;\n    box-shadow: 2px 2px 2px black;\n  }\n\n  #space_info {\n    /* for long space descriptions */\n    /* overflow-x: auto; */\n    overflow-wrap: break-word;\n  }\n\n  #properties {\n    overflow: auto;\n    height: 150vh;\n    flex: 1 1 auto;\n  }\n\n  #properties table {\n    width: 100%;\n  }\n\n  #properties tr.active {\n    background-color: lightyellow;\n  }\n\n  #viz {\n    overflow: auto;\n    flex: 1 1 auto;\n    height: 20vh;\n  }\n\n  #controls_right {\n    right: 0;\n  }\n\n  .hideInDemoMode {\n    display: none !important;\n  }\n\n  #tag_panel {\n    overflow: auto;\n    flex: 1 1 150vh;\n  }\n\n  #tag_search {\n    width: calc(100% - 8px);\n    margin: 4px 0px;\n    padding: 2px;\n  }\n\n  .range_filter {\n    width: 45px;\n  }\n\n  .property_selector {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    margin: 5px 0px;\n  }\n\n  .active {\n    background-color: lightyellow; padding: 3px;\n  }\n\n  .demoModeToggle {\n    /* position: absolute; */\n    /* right: 10px; */\n    /* top: 10px; */\n    /* z-index: 1001; */\n    float: right;\n  }\n\n  .controls_left_selector {\n    float: left;\n    clear: left;\n  }\n\n  .demoModeToggle {\n    /* position: absolute; */\n    /* right: 10px; */\n    /* top: 10px; */\n    /* z-index: 1001; */\n    float: right;\n  }\n\n  /* mobile styles at the end for higher precedence */\n\n  /* mobile (any orientation) */\n  @media (max-width: 960px) {\n    .hideOnMobile {\n      display: none;\n    }\n\n    /* columns are narrower */\n    .column {\n      width: 240px;\n    }\n\n    /* more button-like appearance on iOS */\n    button {\n      -webkit-appearance: textfield;\n    }\n  }\n\n  /* mobile in portrait */\n  @media (max-width: 960px) and (orientation: portrait) {\n    .hideOnMobilePortrait {\n      display: none;\n    }\n\n    /* left column fills whole screen */\n    #controls_left {\n      width: 100%;\n      /* unset flexbox full height that will block user input */\n      min-height: unset;\n      max-height: unset;\n    }\n  }\n\n  /* mobile in landscape */\n  @media (max-width: 960px) and (orientation: landscape) {\n    /* keep basemap and projection selectors from being too wide */\n    .controls_left_dropdown {\n      width: 110px;\n    }\n  }\n\n</style>\n",
    "{#if showHeader}\n  <div style=\"margin: 5px 0 5px 0;\">\n    Top values by\n    <select bind:value=\"valueSort\">\n      <option>count</option>\n      <option>values</option>\n    </select>\n  </div>\n{/if}\n\n<table>\n  <thead>\n    <tr><td style=\"text-align: right;\">#</td><td></td><td>Value</td></tr>\n  </thead>\n  <tbody>\n    {#each valueCounts.slice(0, 50) as [value, count], i }\n      <tr>\n        <td style=\"width: 15px; text-align: right;\">{count}</td>\n        <td style=\"width: 15px;\">\n          <!-- uses color calc code shared with tangram-->\n          {#if valueColorFunction}\n            <span class=\"dot\" style=\"background-color: {valueColorFunction(value)};\">\n            </span>\n          {/if}\n        </td>\n        <td\n          class=\"value_row\"\n          class:active=\"propValue != '' && value == propValue\"\n          on:click=\"set({propValue: (value != propValue ? value : '')})\">\n          {maybeStringifyObject(value)}\n        </td>\n      </tr>\n    {/each}\n  </tbody>\n</table>\n\n{#if valueCounts.length > 50}\n  <i>{valueCounts.length - 50} more {valueCounts.length - 50 > 1 ? 'values' : 'value'} for {prop} not shown</i>\n{/if}\n<script>\n\nexport default {\n  data() {\n    return {\n      prop: null,\n      propValue: null,\n      valueSort: null,\n      valueCounts: [],\n      valueColorFunction: null,\n      showHeader: true\n    }\n  },\n\n  helpers: {\n    maybeStringifyObject(v) {\n      // stringify objects, otherwise just return original object\n      return (v != null && typeof v === 'object') ? JSON.stringify(v) : v;\n    }\n  }\n};\n\n</script>\n\n<style>\n\n.dot {\n  height: 11px;\n  width: 11px;\n  background-color: yellow;\n  border: 2px solid grey;\n  border-radius: 50%;\n  display: inline-block;\n  vertical-align: bottom;\n}\n\n.active {\n  background-color: lightyellow; padding: 3px;\n}\n\n.value_row:hover {\n  background-color: rgba(240, 240, 240, 0.75);\n}\n\n</style>\n",
    "<style>\n\n.propRow > td {\n  padding: 2px;\n}\n\n.propRow > td:hover {\n  background-color: rgba(240, 240, 240, 0.75);\n  cursor: pointer;\n}\n\n.propRow > td.active {\n  background-color: lightyellow;\n}\n\n</style>\n\n<div style=\"{featurePinned ? 'height: 200px; overflow: auto;' : ''}\">\n  <table>\n\n  {#each summaryProps as [prop, value, propStack]}\n    <tr class=\"propRow\">\n      <td style=\"width: 50px;\" class:active=\"prop === featureProp\" on:click=\"fire('selectProp', { prop, propStack })\">\n        <b>{@html Array((propStack.length - 1) * 2).fill('&nbsp;').join('')}{propStack[propStack.length-1]}</b>\n      </td>\n      <td style=\"word-break: break-all;\" class:active=\"value === featurePropValue\" on:click=\"fire('selectValue', { prop, propStack, value })\">\n        {typeof value !== 'object' ? value : ''}\n      </td>\n    </tr>\n  {/each}\n\n  {#if extendedProps.length && summaryProps.length}\n    <tr><td colspan=\"2\"><hr></td></tr>\n  {/if}\n\n  {#each extendedProps as [prop, value, propStack]}\n    <tr class=\"propRow\">\n      <td style=\"width: 50px;\" class:active=\"prop === featureProp\" on:click=\"fire('selectProp', { prop, propStack })\">\n        <b>{@html Array((propStack.length - 1) * 2).fill('&nbsp;').join('')}{propStack[propStack.length-1]}</b>\n      </td>\n      <td style=\"word-break: break-all;\" class:active=\"value === featurePropValue\" on:click=\"fire('selectValue', { prop, propStack, value })\">\n        {typeof value !== 'object' ? value : ''}\n      </td>\n    </tr>\n  {/each}\n\n  {#if !featurePinned && feature}\n    <tr><td colspan=\"2\"><i>Click to see all {Object.keys(feature.properties).length} properties</i></td></tr>\n  {/if}\n</div>\n\n<script>\n\nimport { parsePropStack, parseNestedObject, lookupProperty } from './utils';\n\nexport default {\n  data() {\n    return {\n      featurePinned: false\n    }\n  },\n\n  computed: {\n    summaryProps: ({ feature, featureProp }) => {\n      if (feature == null) {\n        return [];\n      }\n\n      const featurePropStack = parsePropStack(featureProp);\n      const addFeatureProp = (['id', 'name', 'wof:name'].indexOf(featureProp) === -1);\n\n      return [\n          ['id', feature.properties.id, ['id']],\n          ['name', feature.properties.name, ['name']],\n          ['WOF name', feature.properties['wof:name'], ['wof:name']],\n          ['feature id', feature.id, ['feature id']],\n          addFeatureProp ? [featureProp, lookupProperty(feature.properties, featurePropStack) || 'null', featurePropStack] : []\n        ]\n        .filter(x => x[0] && x[1]); // only include props that had values\n    },\n\n    extendedProps: ({ feature, featureProp, featurePinned }) => {\n      if (!featurePinned || feature == null) {\n        return [];\n      }\n\n      return parseNestedObject(feature.properties)\n        .map(r => [r.prop, r.obj, r.propStack])\n        .filter(([p]) => ['id', 'name', 'wof:name'/*, featureProp*/].indexOf(p) === -1)\n        .filter(x => x[0] && x[1]) // only include props that had values\n        // alpha sort, @ properties at bottom\n        .sort(([a], [b]) => a[0] === '@' ? 1 : b[0] === '@' ? -1 : a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0);\n    }\n  }\n\n};\n\n</script>\n",
    "<style>\n\n.equals {\n  width: 70px;\n}\n\n.range {\n  width: 30px;\n}\n\n</style>\n\n<span>\n  <select bind:value=op>\n    <option value=\"\"></option>\n    <option value=\"equals\">equals</option>\n<!--     {#if datatype === 'number'} --> // removing this so we can sort things like 8601 dates\n      <option value=\"range\">range</option>\n<!--     {/if} -->\n  </select>\n</span>\n<span>\n  {#if op != null && op != ''}\n      {#if op === 'equals'}\n        <input\n          class=\"equals\" type=\"text\" placeholder=\"value(s)\"\n          on:keydown=\"event.stopPropagation()\"\n          bind:value=equals\n        >\n      {:elseif op === 'range'}\n        <input\n          class=\"range\" type=\"text\" placeholder=\"min\"\n          on:keydown=\"event.stopPropagation()\"\n          bind:value=min\n        >\n        <input\n          class=\"range\" type=\"text\" placeholder=\"max\"\n          on:keydown=\"event.stopPropagation()\"\n          bind:value=max\n        >\n      {/if}\n  {/if}\n</span>\n\n<script>\n\nimport _ from 'lodash';\n\n// number of milliseconds to delay input update events\nconst INPUT_DEBOUNCE_TIME = 500;\n\nexport default {\n  data() {\n    return {\n      prop: null,\n      datatype: null,\n      initial: null,\n      op: null,\n      equals: '',\n      min: '',\n      max: ''\n    }\n  },\n\n  onstate({ changed, current, previous }) {\n    // first-time initialization with provided values\n    if (!previous && current.initial) {\n      const data = current.initial;\n      this.set({\n        op: data.op,\n        equals: data.equals != null ? data.equals : '',\n        min: data.min != null ? data.min : '',\n        max: data.max != null ? data.max : '',\n      });\n    }\n    // send updates to parent component\n    else if (changed.op || changed.equals || changed.min || changed.max) {\n      let { op, equals, min, max } = current;\n      const { datatype } = this.get();\n\n      // add explicit quotes to numeric searches on string fields\n      if (datatype === 'string' && equals != null && equals.match(/^\\d+$/)) {\n        equals = `\"${equals}\"`;\n      }\n\n      this.updateField({ prop: current.prop, values: { op, equals, min, max } });\n    }\n  },\n\n  methods: {\n\n    // debounced update event to avoid spamming on rapid UI changes\n    updateField: _.debounce(function({ prop, values }) {\n      this.fire('update', { prop, values });\n    }, INPUT_DEBOUNCE_TIME)\n\n  }\n\n};\n\n</script>\n"
  ],
  "names": [],
  "mappings": "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"
}